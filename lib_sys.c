/*
 * lib_sys.c
 *
 *  Created on: Mar 22, 2022
 *      Author: micahbly
 */





/*****************************************************************************/
/*                                Includes                                   */
/*****************************************************************************/

// project includes
#include "lib_sys.h"

#include "a2560_platform.h"
#include "bitmap.h"
#include "event.h"
#include "font.h"
#include "general.h"
#include "list.h"
#include "text.h"
#include "theme.h"
#include "window.h"
#include "startup.h"

// C includes
#include <stdbool.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// A2560 includes
#include <mcp/syscalls.h>
#include <mcp/interrupt.h>


/*****************************************************************************/
/*                               Definitions                                 */
/*****************************************************************************/



/*****************************************************************************/
/*                               Enumerations                                */
/*****************************************************************************/



/*****************************************************************************/
/*                             Global Variables                              */
/*****************************************************************************/

System*			global_system;

// MCP / previous interrupt handler functions for restore on exit
// p_int_handler	global_old_keyboard_interrupt;
// p_int_handler	global_old_mouse_interrupt;
// p_int_handler is defined in mcp/interrupt.h as typedef void (*p_int_handler)();


/*****************************************************************************/
/*                       Private Function Prototypes                         */
/*****************************************************************************/

// Instruct all windows to close / clean themselves up
void Sys_DestroyAllWindows(System* the_system);

//! Instruct every window to update itself and its controls to match the system's current theme
//! This is called as part of Sys_SetTheme().
void Sys_UpdateWindowTheme(System* the_system);

void Sys_RenumberWindows(System* the_system);


//! Event handler for the backdrop window
void Window_BackdropWinEventHandler(EventRecord* the_event);


// **** Debug functions *****

void Sys_Print(System* the_system);


/*****************************************************************************/
/*                       Private Function Definitions                        */
/*****************************************************************************/



//! Instruct every window to update itself and its controls to match the system's current theme
//! This is called as part of Sys_SetTheme().
void Sys_UpdateWindowTheme(System* the_system)
{
 	List*	the_item;
 	
 	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return;
 	}
	
	the_item = *(the_system->list_windows_);

	while (the_item != NULL)
	{
		Window*		this_window = (Window*)(the_item->payload_);
		
		Window_UpdateTheme(this_window);
		
		the_item = the_item->next_item_;
	}
	
	return;
}


void Sys_RenumberWindows(System* the_system)
{
 	List*	the_item;
 	int8_t	win_num = 1;
 	int8_t	this_display_order;
 	
 	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return;
 	}
	
// 	DEBUG_OUT(("%s %d: win count=%i", __func__ , __LINE__, the_system->window_count_));
// 	List_Print(the_system->list_windows_, (void*)&Window_PrintBrief);
	
	the_item = *(the_system->list_windows_);

	while (the_item != NULL)
	{
		Window*		this_window = (Window*)(the_item->payload_);
		
		if (this_window == NULL)
		{
			LOG_ERR(("%s %d: this_window was null, the_item=%p, win_num=%i, win count=%i", __func__ , __LINE__, the_item, win_num, the_system->window_count_));
			Sys_Destroy(&the_system);
		}
		
		if (this_window->is_backdrop_)
		{
			this_display_order = SYS_WIN_Z_ORDER_BACKDROP;
		}
		else
		{
			this_display_order = SYS_MAX_WINDOWS - win_num++;
		}
		
		Window_SetDisplayOrder(this_window, this_display_order);
		
		the_item = the_item->next_item_;
	}
	
	return;
}


//! Event handler for the backdrop window
void Window_BackdropWinEventHandler(EventRecord* the_event)
{
	return;
}


// // interrupt 1 is PS2 keyboard, interrupt 2 is A2560K keyboard
// void Sys_InterruptKeyboard(void);
// 
// // interrupt 4 is PS2 mouse
// void Sys_InterruptMouse(void);


// **** Debug functions *****

void Sys_Print(System* the_system)
{
// 	DEBUG_OUT(("System print out:"));
// 	DEBUG_OUT(("  fontType: %i", the_system->fontType));
// 	DEBUG_OUT(("  firstChar: %i", the_system->firstChar));
// 	DEBUG_OUT(("  lastChar: %i", the_system->lastChar));
// 	DEBUG_OUT(("  widMax: %i", the_system->widMax));
// 	DEBUG_OUT(("  kernMax: %i", the_system->kernMax));
// 	DEBUG_OUT(("  nDescent: %i", the_system->nDescent));
// 	DEBUG_OUT(("  fRectWidth: %i", the_system->fRectWidth));
// 	DEBUG_OUT(("  fRectHeight: %i", the_system->fRectHeight));
// 	DEBUG_OUT(("  owTLoc: %u", the_system->owTLoc));
// 	DEBUG_OUT(("  ascent: %i", the_system->ascent));
// 	DEBUG_OUT(("  descent: %i", the_system->descent));
// 	DEBUG_OUT(("  leading: %i", the_system->leading));
// 	DEBUG_OUT(("  rowWords: %i", the_system->rowWords));	
}




/*****************************************************************************/
/*                        Public Function Definitions                        */
/*****************************************************************************/

// **** CONSTRUCTOR AND DESTRUCTOR *****

// constructor
System* Sys_New(void)
{
	System*			the_system;
	int16_t			i;
	
	
	// LOGIC:
	
	if ( (the_system = (System*)calloc(1, sizeof(System)) ) == NULL)
	{
		LOG_ERR(("%s %d: could not allocate memory to create new system", __func__ , __LINE__));
		goto error;
	}
	LOG_ALLOC(("%s %d:	__ALLOC__	the_system	%p	size	%i", __func__ , __LINE__, the_system, sizeof(System)));

	// event manager
	if ( (the_system->event_manager_ = EventManager_New() ) == NULL)
	{
		LOG_ERR(("%s %d: could not allocate memory to create the event manager", __func__ , __LINE__));
		goto error;
	}
	
	DEBUG_OUT(("%s %d: EventManager created ok. Detecting hardware...", __func__ , __LINE__));
	
	// check what kind of hardware the system is running on
	// LOGIC: we need to know how many screens it has before allocating screen objects
	if (Sys_AutoDetectMachine(the_system) == false)
	{
		LOG_ERR(("%s %d: Detected machine hardware is incompatible with this software", __func__ , __LINE__));
		goto error;
	}
	
	DEBUG_OUT(("%s %d: Hardware detected (%u screens). Creating screens...", __func__ , __LINE__, the_system->num_screens_));

	// screens
	for (i = 0; i < the_system->num_screens_; i++)
	{
		if ( (the_system->screen_[i] = (Screen*)calloc(1, sizeof(Screen)) ) == NULL)
		{
			LOG_ERR(("%s %d: could not allocate memory to create screen object", __func__ , __LINE__));
			goto error;
		}
		LOG_ALLOC(("%s %d:	__ALLOC__	the_system->screen_[%i]	%p	size	%i", __func__ , __LINE__, i, the_system->screen_[i], sizeof(Screen)));
		
		the_system->screen_[i]->id_ = i;
	}

	DEBUG_OUT(("%s %d: Screen(s) created ok.", __func__ , __LINE__, i));
	
	// for systems with only one screen, we will point the 2nd screen to the first, so that any call to 2nd screen works as if it was a call to the first. 
	if (the_system->num_screens_ == 1)
	{
		the_system->screen_[1] = the_system->screen_[0];
	}

	DEBUG_OUT(("%s %d: returning to SysInit()...", __func__ , __LINE__, i));
	
	// LOGIC: we don't have font info yet; just want to make it clear these are not set and not rely on compiler behavior
	the_system->system_font_ = NULL;
	the_system->app_font_ = NULL;
	the_system->theme_ = NULL;
	the_system->active_window_ = NULL;
	the_system->window_count_ = 0;
	
	return the_system;
	
error:
	if (the_system)					Sys_Destroy(&the_system);
	return NULL;
}


// destructor
// frees all allocated memory associated with the passed object, and the object itself
//! @param	the_system: valid pointer to system object
bool Sys_Destroy(System** the_system)
{
	int16_t	i;
	
	if (*the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return false;
	}

	for (i = 0; i < 2; i++)
	{
		if ((*the_system)->screen_[i])
		{
			LOG_ALLOC(("%s %d:	__FREE__	(*the_system)->screen_[i]	%p	size	%i", __func__ , __LINE__, (*the_system)->screen_[i], sizeof(Screen)));
			free((*the_system)->screen_[i]);
			(*the_system)->screen_[i] = NULL;
		}
	}

	if ((*the_system)->system_font_)
	{
		Font_Destroy(&(*the_system)->system_font_);
	}

	if ((*the_system)->app_font_)
	{
		Font_Destroy(&(*the_system)->app_font_);
	}

	if ((*the_system)->event_manager_)
	{
		EventManager_Destroy(&(*the_system)->event_manager_);
	}

	if ((*the_system)->list_windows_)
	{
		Sys_DestroyAllWindows(*the_system);
	}


	LOG_ALLOC(("%s %d:	__FREE__	*the_system	%p	size	%i", __func__ , __LINE__, *the_system, sizeof(System)));
	free(*the_system);
	*the_system = NULL;
	
	return true;
}


//! Instruct all windows to close / clean themselves up
//! @param	the_system: valid pointer to system object
void Sys_DestroyAllWindows(System* the_system)
{
	int16_t		num_nodes = 0;
	List*		the_item;
	
 	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return;
 	}
	
	if (the_system->list_windows_ == NULL)
	{
		DEBUG_OUT(("%s %d: the window list was NULL", __func__ , __LINE__));
		return;
	}
	
	the_item = *(the_system->list_windows_);

	while (the_item != NULL)
	{
		Window*		this_window = (Window*)(the_item->payload_);
		
		Window_Destroy(&this_window);
		++num_nodes;
		--the_system->window_count_;

		the_item = the_item->next_item_;
	}

	// now free up the list items themselves
	List_Destroy(the_system->list_windows_);

	DEBUG_OUT(("%s %d: %i windows closed", __func__ , __LINE__, num_nodes));

	return;
}



// **** System Initialization functions *****

//! Initialize the system (primary entry point for all system initialization activity)
//! Starts up the memory manager, creates the global system object, runs autoconfigure to check the system hardware, loads system and application fonts, allocates a bitmap for the screen.
bool Sys_InitSystem(void)
{
	Font*		the_system_font;
	Font*		the_icon_font;
	Theme*		the_theme;
	int16_t		i;
	
	
	DEBUG_OUT(("%s %d: Initializing System...", __func__, __LINE__));
	
	// initialize the system object
	if ((global_system = Sys_New()) == NULL)
	{
		LOG_ERR(("%s %d: Couldn't instantiate system object", __func__, __LINE__));
		goto error;
	}

	DEBUG_OUT(("%s %d: System object created ok. Initiating list of windows...", __func__, __LINE__));
	
// 	// set the global variable that other classes/libraries need access to.
// 	global_system = the_system;

	DEBUG_OUT(("%s %d: Running Autoconfigure...", __func__, __LINE__));
	
	if (Sys_AutoConfigure(global_system) == false)
	{
		LOG_ERR(("%s %d: Auto configure failed", __func__, __LINE__));
		goto error;
	}
	
	// load 2 fonts, one for titlebar/menus, one for icon text/etc.
	DEBUG_OUT(("%s %d: Loading system font...", __func__, __LINE__));
	
	if ( (the_system_font = Sys_LoadSystemFont()) == NULL)
	{
		LOG_ERR(("%s %d: Failed to load the system font", __func__, __LINE__));
		goto error;
	}
	
	DEBUG_OUT(("%s %d: loading app font...", __func__, __LINE__));
	
	if ( (the_icon_font = Sys_LoadAppFont()) == NULL)
	{
		LOG_ERR(("%s %d: Failed to load the icon font", __func__, __LINE__));
		goto error;
	}
	
	Sys_SetSystemFont(global_system, the_system_font);
	Sys_SetAppFont(global_system, the_icon_font);
	

	DEBUG_OUT(("%s %d: allocating screen bitmap...", __func__, __LINE__));
	
	// allocate the foreground and background bitmaps, then assign them fixed locations in VRAM
	
	// LOGIC: 
	//   The only bitmaps we want pointing to VRAM locations are the system's layer0 and layer1 bitmaps for the screen
	//   Only 1 screen has bitmapped graphics
	//   We assign them fixed spaces in VRAM, 800*600 apart, so that the addresses are good even on a screen resolution change. 
	
	for (i = 0; i < 2; i++)
	{
		Bitmap*		the_bitmap;

		if ( (the_bitmap = Bitmap_New(global_system->screen_[ID_CHANNEL_B]->width_, global_system->screen_[ID_CHANNEL_B]->height_, Sys_GetSystemFont(global_system), PARAM_IN_VRAM)) == NULL)
		{
			LOG_ERR(("%s %d: Failed to create bitmap #%i", __func__, __LINE__, i));
			goto error;
		}
	
		the_bitmap->addr_ = (unsigned char*)((unsigned long)VRAM_START + ((unsigned long)i * (unsigned long)VRAM_OFFSET_TO_NEXT_SCREEN));
		
		Sys_SetScreenBitmap(global_system, the_bitmap, i);
		
		// clear the bitmap
		Bitmap_FillMemory(the_bitmap, 0x00);
	}
	

// 	// load the splash screen and progress bar
// 	if (Startup_ShowSplash() == false)
// 	{
// 		LOG_ERR(("%s %d: Failed to load splash screen. Oh, no!", __func__, __LINE__));
// 		// but who cares, just continue on... 
// 	}

	DEBUG_OUT(("%s %d: loading default theme...", __func__, __LINE__));
	
	if ( (the_theme = Theme_CreateDefaultTheme() ) == NULL)
	{
		LOG_ERR(("%s %d: Failed to create default system theme", __func__, __LINE__));
		goto error;
	}
	
	DEBUG_OUT(("%s %d: height=%i, the...XT_BUTTON]=%p", __func__, __LINE__, the_theme->flex_width_backdrops_[TEXT_BUTTON].height_, the_theme->flex_width_backdrops_[TEXT_BUTTON]));
	DEBUG_OUT(("%s %d: the_theme=%p", __func__, __LINE__, the_theme));

	Theme_Activate(the_theme);
	
	DEBUG_OUT(("%s %d: height=%i, the...XT_BUTTON]=%p", __func__, __LINE__, the_theme->flex_width_backdrops_[TEXT_BUTTON].height_, the_theme->flex_width_backdrops_[TEXT_BUTTON]));
	DEBUG_OUT(("%s %d: the_theme=%p", __func__, __LINE__, the_theme));

	// create the backdrop window and add it to the list of the windows the system tracks
	
	// LOGIC:
	//   Every app will use (or at least have access to) the backdrop window
	//   The backdrop window shares the same bitmap as the Screen
	//   The backdrop window will catch events that drop through the windows in the foreground
	
	if ( Sys_CreateBackdropWindow(global_system) == false)
	{
		LOG_ERR(("%s %d: Failed to create a backdrop window. Fatal error.", __func__, __LINE__));
		goto error;
	}
	
	// Enable mouse pointer -- no idea if this works, f68 emulator doesn't support mouse yet. 
	//R32(VICKYB_MOUSE_CTRL_A2560K) = 1;
	
	// set interrupt handlers
// 	global_old_keyboard_interrupt = sys_int_register(INT_KBD_PS2, &Sys_InterruptKeyboard);
// 	global_old_keyboard_interrupt = sys_int_register(INT_KBD_A2560K, &Sys_InterruptKeyboard);
// 	global_old_mouse_interrupt = sys_int_register(INT_MOUSE, &Sys_InterruptKeyboard);

	DEBUG_OUT(("%s %d: System initialization complete.", __func__, __LINE__));

	return true;
	
error:
	return false;
}





// **** Event-handling functions *****

// see MCP's ps2.c for real examples once real machine available

// // interrupt 1 is PS2 keyboard, interrupt 2 is A2560K keyboard
// void Sys_InterruptKeyboard(void)
// {
// 	printf("keyboard!\n");
// 	return;
// }
// 
// // interrupt 4 is PS2 mouse
// void Sys_InterruptMouse(void)
// {
// 	printf("mouse!\n");
// 	return;
// }




// **** Screen mode/resolution/size functions *****


//! Find out what kind of machine the software is running on, and determine # of screens available
//! @param	the_system: valid pointer to system object
//! @return	Returns false if the machine is known to be incompatible with this software. 
bool Sys_AutoDetectMachine(System* the_system)
{
	struct s_sys_info	sys_info;
	struct s_sys_info*	the_sys_info = &sys_info; // doing this convoluted thing so that C256 macro can fake having sys_get_info

	sys_get_info(the_sys_info);
	the_system->model_number_ = the_sys_info->model;
	//DEBUG_OUT(("%s %d: the_system->model_number_=%u", __func__, __LINE__, the_system->model_number_));
	
	switch (the_system->model_number_)
	{
		case MACHINE_C256_U:
		case MACHINE_C256_GENX:
		case MACHINE_C256_UPLUS:
			DEBUG_OUT(("%s %d: this application is not compatible with the %s.", __func__, __LINE__, the_sys_info->model_name));
			return false;
			break;
			
		case MACHINE_C256_FMX:
			the_system->num_screens_ = 1;
			break;
			
		case MACHINE_A2560U_PLUS:
		case MACHINE_A2560U:
			the_system->num_screens_ = 1;
			break;
			
		case MACHINE_A2560X:
		case MACHINE_A2560K:
			the_system->num_screens_ = 2;		
			break;
	}
	
	return true;
}


//! Find out what kind of machine the software is running on, and configure the passed screen accordingly
//! Configures screen settings, RAM addresses, etc. based on known info about machine types
//! Configures screen width, height, total text rows and cols, and visible text rows and cols by checking hardware
//! @param	the_system: valid pointer to system object
//! @return	Returns false if the machine is known to be incompatible with this software. 
bool Sys_AutoConfigure(System* the_system)
{
	int16_t				i;
	
	switch (the_system->model_number_)
	{
		case MACHINE_C256_U:
		case MACHINE_C256_GENX:
		case MACHINE_C256_UPLUS:
			DEBUG_OUT(("%s %d: this application is not compatible with Foenix hardware ID %u.", __func__, __LINE__, the_system->model_number_));
			return false;
			break;
			
		case MACHINE_C256_FMX:
			the_system->screen_[ID_CHANNEL_A]->vicky_ = P32(VICKY_C256FMX);
			the_system->screen_[ID_CHANNEL_A]->text_ram_ = TEXTA_RAM_C256FMX;
			the_system->screen_[ID_CHANNEL_A]->text_attr_ram_ = TEXTA_ATTR_C256FMX;
			the_system->screen_[ID_CHANNEL_A]->text_font_ram_ = FONT_MEMORY_BANK_C256FMX;
			the_system->screen_[ID_CHANNEL_B]->vicky_ = P32(VICKY_C256FMX);
			the_system->screen_[ID_CHANNEL_B]->text_ram_ = TEXTA_RAM_C256FMX;
			the_system->screen_[ID_CHANNEL_B]->text_attr_ram_ = TEXTA_ATTR_C256FMX;
			the_system->screen_[ID_CHANNEL_B]->text_font_ram_ = FONT_MEMORY_BANK_C256FMX;
			break;
			
		case MACHINE_A2560U_PLUS:
		case MACHINE_A2560U:
			the_system->screen_[ID_CHANNEL_A]->vicky_ = P32(VICKY_A2560U);
			the_system->screen_[ID_CHANNEL_A]->text_ram_ = TEXT_RAM_A2560U;
			the_system->screen_[ID_CHANNEL_A]->text_attr_ram_ = TEXT_ATTR_A2560U;
			the_system->screen_[ID_CHANNEL_A]->text_font_ram_ = FONT_MEMORY_BANK_A2560U;
			break;
			
		case MACHINE_A2560X:
		case MACHINE_A2560K:			
			the_system->screen_[ID_CHANNEL_A]->vicky_ = P32(VICKY_A2560K_A);
			the_system->screen_[ID_CHANNEL_A]->text_ram_ = TEXTA_RAM_A2560K;
			the_system->screen_[ID_CHANNEL_A]->text_attr_ram_ = TEXTA_ATTR_A2560K;
			the_system->screen_[ID_CHANNEL_A]->text_font_ram_ = FONT_MEMORY_BANKA_A2560K;

			the_system->screen_[ID_CHANNEL_B]->vicky_ = P32(VICKY_A2560K_B);
			the_system->screen_[ID_CHANNEL_B]->text_ram_ = TEXTB_RAM_A2560K;
			the_system->screen_[ID_CHANNEL_B]->text_attr_ram_ = TEXTB_ATTR_A2560K;
			the_system->screen_[ID_CHANNEL_B]->text_font_ram_ = FONT_MEMORY_BANKB_A2560K;
		
			break;

	}

	// set some things that aren't machine-dependent
	for (i = 0; i < the_system->num_screens_; i++)
	{
		the_system->screen_[i]->rect_.MinX = 0;
		the_system->screen_[i]->rect_.MinY = 0;	
		the_system->screen_[i]->text_temp_buffer_1_[0] = '\0';
		the_system->screen_[i]->text_temp_buffer_2_[0] = '\0';
		the_system->screen_[i]->text_font_width_ = TEXT_FONT_WIDTH_A2560;
		the_system->screen_[i]->text_font_height_ = TEXT_FONT_HEIGHT_A2560;

		// use auto configure to set resolution, text cols, margins, etc
		if (Sys_DetectScreenSize(the_system->screen_[i]) == false)
		{
			LOG_ERR(("%s %d: Unable to auto-configure screen resolution", __func__, __LINE__));
			return false;
		}
	
		DEBUG_OUT(("%s %d: This screen (id=%i: %i x %i, with %i x %i text (%i x %i visible)", __func__, __LINE__, 
			the_system->screen_[i]->id_,
			the_system->screen_[i]->width_, 
			the_system->screen_[i]->height_, 
			the_system->screen_[i]->text_mem_cols_, 
			the_system->screen_[i]->text_mem_rows_, 
			the_system->screen_[i]->text_cols_vis_, 
			the_system->screen_[i]->text_rows_vis_
			));
	}
	
	return true;
}


//! Switch machine into graphics mode
//! @param	the_system: valid pointer to system object
bool Sys_SetModeGraphics(System* the_system)
{	
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was NULL", __func__, __LINE__));
		return false;
	}
	
	// LOGIC:
	//   On an A2560K or X, the only screen that has a text/graphics mode is the Channel B screen
	
	// switch to graphics mode by setting graphics mode bit, and setting bitmap engine enable bit
	//*the_screen->vicky_ = (*the_screen->vicky_ & GRAPHICS_MODE_MASK | (GRAPHICS_MODE_GRAPHICS) | GRAPHICS_MODE_EN_BITMAP);
	R32(the_system->screen_[ID_CHANNEL_B]->vicky_) = (*the_system->screen_[ID_CHANNEL_B]->vicky_ & GRAPHICS_MODE_MASK | (GRAPHICS_MODE_GRAPHICS) | GRAPHICS_MODE_EN_BITMAP);

	// enable bitmap layers 0 and 1
	R32(the_system->screen_[ID_CHANNEL_B]->vicky_ + BITMAP_L0_CTRL_L) = 0x01;
	#ifndef _f68_	// f68 does not do compositing, so if bitmap layer1 is enabled, it blocks everything else
	R32(the_system->screen_[ID_CHANNEL_B]->vicky_ + BITMAP_L1_CTRL_L) = 0x01;
	#else
	R32(the_system->screen_[ID_CHANNEL_B]->vicky_ + BITMAP_L1_CTRL_L) = 0x00;
	#endif
	
	return true;
}


//! Switch machine into text mode
//! @param	the_system: valid pointer to system object
//! @param as_overlay: If true, sets text overlay mode (text over graphics). If false, sets full text mode (no graphics);
bool Sys_SetModeText(System* the_system, bool as_overlay)
{	
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was NULL", __func__, __LINE__));
		return false;
	}
	
	// LOGIC:
	//   On an A2560K or X, the only screen that has a text/graphics mode is the Channel B screen
	
	// switch to yrcy mode by unsetting graphics mode bit, and setting bitmap engine enable bit
	//*the_screen->vicky_ = (*the_screen->vicky_ & GRAPHICS_MODE_MASK | (GRAPHICS_MODE_GRAPHICS) | GRAPHICS_MODE_EN_BITMAP);
	if (as_overlay)
	{
		R32(the_system->screen_[ID_CHANNEL_B]->vicky_) = (*the_system->screen_[ID_CHANNEL_B]->vicky_ & GRAPHICS_MODE_MASK | GRAPHICS_MODE_TEXT | GRAPHICS_MODE_TEXT_OVER | GRAPHICS_MODE_GRAPHICS | GRAPHICS_MODE_EN_BITMAP);
		
		// c256foenix, discord 2022/03/10
		// Normally, for example, if you setup everything to be in bitmap mode, and you download an image in VRAM and you can see it properly... If you turn on overlay, then you will see on top of that same image, your text that you had before.
		// Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
		// Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
		// Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
		// Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
		// all of these should be ON
	}
	else
	{
		R32(the_system->screen_[ID_CHANNEL_B]->vicky_) = (*the_system->screen_[ID_CHANNEL_B]->vicky_ & GRAPHICS_MODE_MASK | GRAPHICS_MODE_TEXT);
		
		// disable bitmap layers 0 and 1
		R32(the_system->screen_[ID_CHANNEL_B]->vicky_ + BITMAP_L0_CTRL_L) = 0x00;
		R32(the_system->screen_[ID_CHANNEL_B]->vicky_ + BITMAP_L1_CTRL_L) = 0x00;
	}
	
	return true;
}


//! Detect the current screen mode/resolution, and set # of columns, rows, H pixels, V pixels, accordingly
bool Sys_DetectScreenSize(Screen* the_screen)
{
	screen_resolution	new_mode;
	uint32_t			the_vicky_value;
	unsigned char		the_video_mode_bits;
	uint32_t			the_border_control_value;
	int16_t				border_x_cols;
	int16_t				border_y_cols;
	int16_t				border_x_pixels;
	int16_t				border_y_pixels;
	
	if (the_screen == NULL)
	{
		LOG_ERR(("%s %d: passed screen was NULL", __func__, __LINE__));
		return false;
	}

	// detect the video mode and set resolution based on it
	
	//v = (unsigned char*)the_screen->vicky_;	
	the_vicky_value = *the_screen->vicky_;
	the_video_mode_bits = (*the_screen->vicky_ >> 8) & 0xff;
	//DEBUG_OUT(("%s %d: vicky value=%x, video mode bits=%x", __func__, __LINE__, the_vicky_value, the_video_mode_bits));
	
	if (the_screen->vicky_ == P32(VICKY_A2560K_A))
	{
		// LOGIC: A2560K channel A only has 2 video modes, 1024x768 and 800x600. If bit 11 is set, it's 1024. 
		
		//DEBUG_OUT(("%s %d: vicky identified as VICKY_A2560K_A", __func__, __LINE__));

		if (the_video_mode_bits & VICKY_IIIA_RES_1024X768_FLAGS)
		{
			new_mode = RES_1024X768;
		}
		else
		{
			new_mode = RES_800X600;
		}
	}
	else if (the_screen->vicky_ == P32(VICKY_A2560K_B))
	{
		// LOGIC: 
		//   A2560K channel B only has 3 video modes, 800x600, 640x480, and 640x400 (currently non-functional)
		//   if bit 8 is set, it's 800x600, if bits 8/9 both set, it's 640x400. 

		//DEBUG_OUT(("%s %d: vicky identified as VICKY_A2560K_B", __func__, __LINE__));

		if (the_video_mode_bits & VICKY_IIIB_RES_800X600_FLAGS)
		{
			new_mode = RES_800X600;
		}
		else if (the_video_mode_bits & VICKY_IIIB_RES_640X400_FLAGS)
		{
			new_mode = RES_640X400;
		}
		else
		{
			new_mode = RES_640X480;
		}
	}
	else if (the_screen->vicky_ == P32(VICKY_A2560U))
	{
 		//   A2560U has 1 channel with 3 video modes, 800x600, 640x480, and 640x400 (currently non-functional)
		//   if bit 8 is set, it's 800x600, if bits 8/9 both set, it's 640x400. 

		//DEBUG_OUT(("%s %d: vicky identified as VICKY_A2560U", __func__, __LINE__));

		if (the_video_mode_bits & VICKY_II_RES_800X600_FLAGS)
		{
			new_mode = RES_800X600;
		}
		else if (the_video_mode_bits & VICKY_II_RES_640X400_FLAGS)
		{
			new_mode = RES_640X400;
		}
		else
		{
			new_mode = RES_640X480;
		}
	}
	else if (the_screen->vicky_ == P32(VICKY_C256FMX))
	{
 		//   C256FMX has 1 channel with 2 video modes, 800x600 and 640x480
		//   if bit 8 is set, it's 800x600, if not set it's 640x400. VIDEO_MODE_BIT0/VIDEO_MODE_BIT1
		//   if bit 9 is set, it doubles pixel size, bringing resolution down to 400x300 or 320x200. VICKY_II_PIX_DOUBLER_FLAGS

		//DEBUG_OUT(("%s %d: vicky identified as VICKY_C256FMX", __func__, __LINE__));

		if (the_video_mode_bits & VIDEO_MODE_BIT1)
		{
			new_mode = RES_800X600;
		}
		else
		{
			new_mode = RES_640X480;
		}
	}
	else
	{
		LOG_ERR(("%s %d: The VICKY register on this machine doesn't match one I know of. I won't be able to figure out what the screen size is.", __func__, __LINE__));
		return false;
	}

	switch (new_mode)
	{
		case RES_640X400:
			the_screen->width_ = 640;	
			the_screen->height_ = 400;
			//DEBUG_OUT(("%s %d: set to RES_640X400", __func__, __LINE__));
			break;
			
		case RES_640X480:
			the_screen->width_ = 640;	
			the_screen->height_ = 480;
			//DEBUG_OUT(("%s %d: set to RES_640X480", __func__, __LINE__));
			break;
			
		case RES_800X600:
			the_screen->width_ = 800;	
			the_screen->height_ = 600;
			//DEBUG_OUT(("%s %d: set to RES_800X600", __func__, __LINE__));
			break;
			
		case RES_1024X768:
			the_screen->width_ = 1024;	
			the_screen->height_ = 768;
			//DEBUG_OUT(("%s %d: set to 1024x768", __func__, __LINE__));
			break;		
	}
	
	// detect borders, and set text cols/rows based on resolution modified by borders (if any)
 	the_border_control_value = R32(the_screen->vicky_ + BORDER_CTRL_OFFSET_L);
	border_x_pixels = (the_border_control_value >> 8) & 0xFF & 0x3F;
	border_y_pixels = (the_border_control_value >> 16) & 0xFF & 0x3F;
	border_x_cols = border_x_pixels * 2 / the_screen->text_font_width_;
	border_y_cols = border_y_pixels * 2 / the_screen->text_font_height_;
// 	DEBUG_OUT(("%s %d: border xcols=%i, ycols=%i", __func__, __LINE__, border_x_cols, border_y_cols));

	the_screen->text_mem_cols_ = the_screen->width_ / the_screen->text_font_width_;
	the_screen->text_mem_rows_ = the_screen->height_ / the_screen->text_font_height_;
	the_screen->text_cols_vis_ = the_screen->text_mem_cols_ - border_x_cols;
	the_screen->text_rows_vis_ = the_screen->text_mem_rows_ - border_y_cols;
	the_screen->rect_.MaxX = the_screen->width_;
	the_screen->rect_.MaxY = the_screen->height_;	
	
	return true;
}


//! Change video mode to the one passed.
//! @param	the_screen: valid pointer to the target screen to operate on
//! @param	new_mode: One of the enumerated screen_resolution values. Must correspond to a valid VICKY video mode for the host machine. See VICKY_IIIA_RES_800X600_FLAGS, etc. defined in a2560_platform.h
//! @return	returns false on any error/invalid input.
bool Sys_SetVideoMode(Screen* the_screen, screen_resolution new_mode)
{
	unsigned char	new_mode_flag = 0xFF;
	
	if (the_screen == NULL)
	{
		LOG_ERR(("%s %d: passed screen was NULL", __func__, __LINE__));
		return false;
	}

	// TODO: figure out smarter way of knowing which video modes are legal for the machine being run on
	if (the_screen->vicky_ == P32(VICKY_A2560K_A))
	{
		//DEBUG_OUT(("%s %d: vicky identified as VICKY_A2560K_A", __func__, __LINE__));
		
		if (new_mode == RES_800X600)
		{
			new_mode_flag = VICKY_IIIA_RES_800X600_FLAGS;
		}
		else if (new_mode == RES_1024X768)
		{
			new_mode_flag = VICKY_IIIA_RES_1024X768_FLAGS;
		}
	}
	else if (the_screen->vicky_ == P32(VICKY_A2560K_B))
	{
		//DEBUG_OUT(("%s %d: vicky identified as VICKY_A2560K_B", __func__, __LINE__));
		
		if (new_mode == RES_640X400)
		{
			LOG_WARN(("%s %d: 640x400 mode is not yet available in hardware", __func__, __LINE__));
			//new_mode_flag = VICKY_IIIB_RES_640X400_FLAGS;
		}
		else if (new_mode == RES_640X480)
		{
			new_mode_flag = VICKY_IIIB_RES_640X480_FLAGS;
		}
		else if (new_mode == RES_800X600)
		{
// 			DEBUG_OUT(("%s %d: RES_800X600", __func__, __LINE__));
			new_mode_flag = VICKY_IIIB_RES_800X600_FLAGS;
		}
	}
	else if (the_screen->vicky_ == P32(VICKY_A2560U))
	{
 		//DEBUG_OUT(("%s %d: vicky identified as VICKY_A2560U", __func__, __LINE__));
		if (new_mode == RES_640X400)
		{
			new_mode_flag = VICKY_II_RES_640X400_FLAGS;
		}
		else if (new_mode == RES_640X480)
		{
			new_mode_flag = VICKY_II_RES_640X480_FLAGS;
		}
		else if (new_mode == RES_800X600)
		{
			new_mode_flag = VICKY_II_RES_800X600_FLAGS;
		}
	}
	else if (the_screen->vicky_ == P32(VICKY_C256FMX))
	{
 		//DEBUG_OUT(("%s %d: vicky identified as VICKY_C256FMX", __func__, __LINE__));
		if (new_mode == RES_640X480)
		{
			new_mode_flag = VICKY_II_RES_640X480_FLAGS;
		}
		else if (new_mode == RES_800X600)
		{
			new_mode_flag = VICKY_II_RES_800X600_FLAGS;
		}
	}
 	//DEBUG_OUT(("%s %d: specified video mode = %u, flag=%u", __func__, __LINE__, new_mode, new_mode_flag));
	
	if (new_mode_flag == 0xFF)
	{
		LOG_ERR(("%s %d: specified video mode is not legal for this screen %u", __func__, __LINE__, new_mode));
		return false;
	}
	
 	//DEBUG_OUT(("%s %d: vicky before = %x", __func__, __LINE__, *the_screen->vicky_ ));
	*the_screen->vicky_ = (*the_screen->vicky_ & VIDEO_MODE_MASK | (new_mode_flag << 8));
 	//DEBUG_OUT(("%s %d: vicky after = %x", __func__, __LINE__, *the_screen->vicky_ ));
	
	// teach screen about the new settings
	if (Sys_DetectScreenSize(the_screen) == false)
	{
		LOG_ERR(("%s %d: Changed screen resolution, but the selected resolution could not be handled", __func__, __LINE__, new_mode));
		return false;
	}

	// tell the MCP that we changed res so it can update it's internal col sizes, etc.  - this function is not exposed in MCP headers yet
	//sys_text_setsizes();
	
	return true;
}


//! Enable or disable the hardware cursor in text mode, for the specified screen
//! @param	the_system: valid pointer to system object
//! @param	the_screen: valid pointer to the target screen to operate on
//! @param enable_it: If true, turns the hardware blinking cursor on. If false, hides the hardware cursor;
bool Sys_EnableTextModeCursor(System* the_system, Screen* the_screen, bool enable_it)
{
	if (the_screen == NULL)
	{
		LOG_ERR(("%s %d: passed screen was NULL", __func__, __LINE__));
		return false;
	}

	if (enable_it)
	{
		R32(the_screen->vicky_ + CURSOR_CTRL_OFFSET_L) = 1;
	}
	else
	{
		R32(the_screen->vicky_ + CURSOR_CTRL_OFFSET_L) = 0;
	}
	
	return true;
}




// **** Window management functions *****


//! Add this window to the list of windows and make it the currently active window
//! @param	the_system: valid pointer to system object
//! @return	Returns false if adding this window would exceed the system's hard cap on the number of available windows
bool Sys_AddToWindowList(System* the_system, Window* the_new_window)
{
	List*	the_new_item;
	int8_t	new_display_order;
	
	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		Sys_Destroy(&the_system); // crash early, crash often
 	}
	
 	if (the_new_window == NULL)
 	{
		LOG_ERR(("%s %d: passed window object was null", __func__ , __LINE__));
		Sys_Destroy(&the_system); // crash early, crash often
 	}

	// are there too many windows already? 
	if (the_system->window_count_ >= SYS_MAX_WINDOWS)
	{
		LOG_ERR(("%s %d: No more windows can be opened!", __func__ , __LINE__));
		return false;
	}

	the_new_item = List_NewItem((void*)the_new_window);
	
	// have any windows been created yet? If not, need to allocate the pointer to the list
	if (the_system->window_count_ < 1)
	{
		// initiate the list of windows
		if ( (the_system->list_windows_ = (List**)calloc(1, sizeof(List*)) ) == NULL)
		{
			LOG_ERR(("%s %d: could not allocate memory to create new list of windows", __func__ , __LINE__));
			return false;
		}
		LOG_ALLOC(("%s %d:	__ALLOC__	the_system->list_windows_	%p	size	%i", __func__ , __LINE__, the_system->list_windows_, sizeof(List*)));
		
		*the_system->list_windows_ = the_new_item;
	}
	else
	{
		List_AddItem(the_system->list_windows_, the_new_item);
	}
	
	new_display_order = SYS_MAX_WINDOWS;
	Window_SetDisplayOrder(the_new_window, new_display_order);
	
	++the_system->window_count_;
	
	Sys_SetActiveWindow(the_system, the_new_window);

//  	DEBUG_OUT(("%s %d: window count after=%i", __func__, __LINE__, the_system->window_count_));
// 	List_Print(the_system->list_windows_, (void*)&Window_PrintBrief);
	
	return true;
}


// create the backdrop window for the system
//! @param	the_system: valid pointer to system object
bool Sys_CreateBackdropWindow(System* the_system)
{
	Screen*				the_screen;
	Window*				the_window;
	NewWinTemplate*		the_win_template;
	static char*		the_win_title = "_backdrop";

 	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return false;
 	}

	if ( (the_win_template = Window_GetNewWinTemplate(the_win_title)) == NULL)
	{
		LOG_ERR(("%s %d: Could not get a new window template", __func__ , __LINE__));
		return false;
	}
		
	the_screen = the_system->screen_[ID_CHANNEL_B];
	
	the_win_template->x_ = 0;
	the_win_template->y_ = 0;
	the_win_template->width_ = the_screen->width_;
	the_win_template->height_ = the_screen->height_;
	the_win_template->min_width_ = the_screen->width_;
	the_win_template->min_height_ = the_screen->height_;
	the_win_template->max_width_ = the_screen->width_;
	the_win_template->max_height_ = the_screen->height_;

	the_win_template->type_ = WIN_BACKDROP;
	the_win_template->is_backdrop_ = true;
	the_win_template->can_resize_ = false;
	
	if ( (the_window = Window_New(the_win_template, &Window_BackdropWinEventHandler)) == NULL)
	{
		DEBUG_OUT(("%s %d: Couldn't instantiate the backdrop window", __func__, __LINE__));
		goto error;
	}

	// make the window visible (Window_New always sets windows to invisible so they don't render before you need them to)
	Window_SetVisible(the_window, true);
	
	return true;
	
error:
	return false;
}


// return the active window
//! @param	the_system: valid pointer to system object
Window* Sys_GetActiveWindow(System* the_system)
{
 	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return NULL;
 	}
	
	return the_system->active_window_;
}


// return the backdrop window
//! @param	the_system: valid pointer to system object
Window* Sys_GetBackdropWindow(System* the_system)
{
 	List*	the_item;
 	
 	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return NULL;
 	}
	
	the_item = *(the_system->list_windows_);

	while (the_item != NULL)
	{
		Window*		this_window = (Window*)(the_item->payload_);
		
		if (Window_IsBackdrop(this_window))
		{
			return this_window;
		}

		the_item = the_item->next_item_;
	}
	
	return NULL;
}


// return a reference to the next window in the system's list, excluding backdrop windows
//! @param	the_system: valid pointer to system object
Window* Sys_GetNextWindow(System* the_system)
{
	Window*		current_window;
	Window*		next_window;
	List*		current_window_item;
	List*		next_window_item;
	bool		ok = false;
	bool		looped = false;

 	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return NULL;
 	}
	
	if (the_system->window_count_ < 1)
	{
		return NULL;
	}
	
	current_window = Sys_GetActiveWindow(the_system);

	DEBUG_OUT(("%s %d: window list:", __func__, __LINE__));
	List_Print(the_system->list_windows_, (void*)&Window_PrintBrief);

	// if no active window (possible on a window close), then use the first window as starting point
	// otherwise, use active window as starting point
	if (current_window == NULL)
	{
		current_window_item = List_GetFirst(the_system->list_windows_);
		LOG_ERR(("%s %d: no active window, first item=%p", __func__ , __LINE__, current_window_item));
		looped = true;
	}
	else
	{
		current_window_item = List_FindThisObject(the_system->list_windows_, (void*)current_window);
	}	

	if (current_window_item == NULL)
	{
		LOG_ERR(("%s %d: couldn't find current window in the list of windows", __func__ , __LINE__));
		Sys_Destroy(&the_system); // crash early, crash often
		return NULL; // shut up warnings
	}
	
	next_window_item = current_window_item->next_item_;
	
	while (!ok)
	{	
		if (next_window_item == NULL)
		{
			// loop back to start of List
			if (looped == false)
			{
				next_window_item = List_GetFirst(the_system->list_windows_);
				looped = true;
				DEBUG_OUT(("%s %d: going back to first item in window list", __func__ , __LINE__));
			}
			else
			{
				DEBUG_OUT(("%s %d: have already looped once; giving up", __func__ , __LINE__));
				current_window = (Window*)current_window_item->payload_; // there is always ONE window until we do Sys_Destroy()
				return current_window;
			}
		}
		else
		{
			// check for backdrop and skip.
			next_window = (Window*)next_window_item->payload_;
			DEBUG_OUT(("%s %d: backdrop check: this window is '%s'", __func__ , __LINE__, next_window->title_));

			if (next_window->is_backdrop_)
			{
				next_window_item = next_window_item->next_item_;
				DEBUG_OUT(("%s %d: was backdrop", __func__ , __LINE__));
			}
			else
			{
				ok = true;
				DEBUG_OUT(("%s %d: ok reached", __func__ , __LINE__));
			}
		}
	}
	
	return next_window;
}


// return a reference to the previous window in the system's list, excluding backdrop windows
//! @param	the_system: valid pointer to system object
Window* Sys_GetPreviousWindow(System* the_system)
{
	Window*		current_window;
	Window*		next_window;
	List*		current_window_item;
	List*		next_window_item;
	bool		ok = false;

 	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return NULL;
 	}
	
	if (the_system->window_count_ < 1)
	{
		return NULL;
	}
	
	current_window = Sys_GetActiveWindow(the_system);

	if (current_window == NULL)
	{
		return NULL;
	}

	if (the_system->window_count_ < 2)
	{
		return current_window;
	}
	
	current_window_item = List_FindThisObject(the_system->list_windows_, (void*)current_window);

	if (current_window_item == NULL)
	{
		LOG_ERR(("%s %d: couldn't find current window in the list of windows", __func__ , __LINE__));
		Sys_Destroy(&the_system); // crash early, crash often
		return NULL;
	}
	
	next_window_item = current_window_item->prev_item_;
	
	while (!ok)
	{	
		if (next_window_item == NULL)
		{
			// loop back to start of List
			next_window_item = List_GetLast(the_system->list_windows_);
		}
		else
		{
			// check for backdrop and skip.
			next_window = (Window*)next_window_item->payload_;

			if (next_window->is_backdrop_)
			{
				next_window_item = next_window_item->prev_item_;
			}
			else
			{
				ok = true;
			}
		}
	}
	
	return next_window;
}


// Find the Window under the mouse -- accounts for z depth (topmost window will be found)
//! @param	the_system: valid pointer to system object
//! @param	x: global horizontal coordinate
//! @param	y: global vertical coordinate
Window* Sys_GetWindowAtXY(System* the_system, int16_t x, int16_t y)
{
 	List*	the_item;

 	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return NULL;
 	}
	
	if (the_system->window_count_ < 1)
	{
		return NULL;
	}
	
	if (x < 0 || y < 0)
	{
		return NULL;
	}
	
	// LOGIC:
	//   OS/f windows are all known by the system
	//   each window has a display order property set by the system, from low to high being backmost to frontmost
	//   the system also keeps them sorted in its list, with first item being front most
		
	the_item = *(the_system->list_windows_);

	while (the_item != NULL)
	{
 		bool		in_this_win;
		Window*		this_window = (Window*)(the_item->payload_);
		
		in_this_win = General_PointInRect(x, y, this_window->global_rect_);
		
		if (in_this_win)
		{
			DEBUG_OUT(("%s %d: window at %i, %i = '%s'", __func__, __LINE__, x, y, this_window->title_));
			return this_window;
		}

		the_item = the_item->next_item_;
	}
	
	return NULL;
}


//! Set the passed window to the active window, and marks the previously active window as inactive
//! NOTE: This will resort the list of windows to move the (new) active one to the front
//! NOTE: The exception to this is that the backdrop window is never moved in front of other windows
//! @param	the_system: valid pointer to system object
bool Sys_SetActiveWindow(System* the_system, Window* the_window)
{
	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return false;
 	}

	if (the_system->active_window_ != NULL)
	{
		Window_SetActive(the_system->active_window_, false);
	}
	
	the_system->active_window_ = the_window;

	Window_SetActive(the_window, true);

	if (the_window->is_backdrop_)
	{
		return true;
	}
	
	//DEBUG_OUT(("%s %d: window list before change of active window:", __func__, __LINE__));
	//List_Print(the_system->list_windows_, (void*)&Window_PrintBrief);
	
	the_window->display_order_ = SYS_WIN_Z_ORDER_NEWLY_ACTIVE;
	List_InitMergeSort(the_system->list_windows_, &Window_CompareDisplayOrder);
	
	//DEBUG_OUT(("%s %d: window list after change of active window:", __func__, __LINE__));
	//List_Print(the_system->list_windows_, (void*)&Window_PrintBrief);
	
	// that changes their linked order, but doesn't renumber their display_order_; need that too
	Sys_RenumberWindows(the_system);
	
	// temp
	Sys_Render(global_system);
	
	return true;
}


// List-sort compatible function for sorting windows by their display order property
bool Window_CompareDisplayOrder(void* first_payload, void* second_payload)
{
	Window*		win_1 = (Window*)first_payload;
	Window*		win_2 = (Window*)second_payload;

	if (win_1->display_order_ < win_2->display_order_)
	{
		//DEBUG_OUT(("%s %d: win1 ('%s') behind win2 ('%s')", __func__, __LINE__, win_1->title_, win_2->title_));
		return true;
	}
	else
	{
		//DEBUG_OUT(("%s %d: win1 ('%s') in front of win2 ('%s')", __func__, __LINE__, win_1->title_, win_2->title_));
		return false;
	}
}


// remove one window from system's list of windows, and close it
void Sys_CloseOneWindow(System* the_system, Window* the_window)
{
	Window*		the_next_window;
	bool		need_different_active_window = false;
	List*		this_window_item;

 	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return;
 	}
	
	// check that we have a window
	if (the_window == NULL)
	{
		LOG_ERR(("%s %d: passed a null window -- no window to close", __func__ , __LINE__));
		return;
	}

	this_window_item = List_FindThisObject(the_system->list_windows_, (void*)the_window);

	if (this_window_item == NULL)
	{
		LOG_ERR(("%s %d: couldn't find current window in the list of windows", __func__ , __LINE__));
		Sys_Destroy(&the_system); // crash early, crash often
		return; // shut up warnings
	}
	
	// if this was active window, we'll need to pick a new one after we delete it
	need_different_active_window = (the_system->active_window_ == the_window);
	DEBUG_OUT(("%s %d: closing active window=%i", __func__ , __LINE__, need_different_active_window));
	
	if (need_different_active_window)
	{
		the_system->active_window_ = NULL;
	}
	
	// nullify any upcoming events that reference this Window
	EventManager_RemoveEventsForWindow(the_window);
	
	// destroy the window, making sure to set a new active window
	Window_Destroy(&the_window);
	DEBUG_OUT(("%s %d: window destroyed", __func__ , __LINE__));
	--the_system->window_count_;
	List_RemoveItem(the_system->list_windows_, this_window_item);
	LOG_ALLOC(("%s %d:	__FREE__	the_item	%p	size	%i", __func__ , __LINE__, this_window_item, sizeof(List)));
	free(this_window_item);
	this_window_item = NULL;
	
	if (need_different_active_window)
	{
		DEBUG_OUT(("%s %d: trying to get next window...", __func__ , __LINE__));
		the_next_window = Sys_GetNextWindow(the_system);

		if (the_next_window != NULL)
		{
			Sys_SetActiveWindow(the_system, the_next_window); // this also calls system render
		}

		DEBUG_OUT(("%s %d: new active window='%s'", __func__ , __LINE__, the_system->active_window_->title_));		
	}
	else
	{
		// don't need a new active window, but do need to re-render all windows
		Sys_Render(global_system);		
	}
	
	return;
}





// **** Other GET functions *****


//! @param	the_system: valid pointer to system object
Theme* Sys_GetTheme(System* the_system)
{
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return NULL;
	}
	
	return the_system->theme_;
}

//! @param	the_system: valid pointer to system object
Font* Sys_GetSystemFont(System* the_system)
{
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return NULL;
	}
	
	return the_system->system_font_;
}


//! @param	the_system: valid pointer to system object
Font* Sys_GetAppFont(System* the_system)
{
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return NULL;
	}
	
	return the_system->app_font_;
}


//! @param	the_system: valid pointer to system object
Screen* Sys_GetScreen(System* the_system, int16_t channel_id)
{
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return NULL;
	}
	
	if (channel_id != ID_CHANNEL_A && channel_id != ID_CHANNEL_B)
	{
		LOG_ERR(("%s %d: passed channel_id (%i) was invalid", __func__ , __LINE__, channel_id));
		return NULL;
	}
	
	return the_system->screen_[channel_id];
}


//! NOTE: Foenix systems only have 1 screen with bitmap graphics, even if the system has 2 screens overall. The bitmap returned will always be from the appropriate channel (A or B).
//! @param	the_system: valid pointer to system object
Bitmap* Sys_GetScreenBitmap(System* the_system, bitmap_layer the_layer)
{
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return NULL;
	}
	
	if (the_layer > fore_layer)
	{
		LOG_ERR(("%s %d: passed layer (%i) was invalid", __func__ , __LINE__, the_layer));
		return NULL;
	}
	
	return the_system->screen_[ID_CHANNEL_B]->bitmap_[the_layer];
}


//! @param	the_system: valid pointer to system object
EventManager* Sys_GetEventManager(System* the_system)
{
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return NULL;
	}
	
	return the_system->event_manager_;
}





// **** Other SET functions *****

//! @param	the_system: valid pointer to system object
void Sys_SetSystemFont(System* the_system, Font* the_font)
{
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return;
	}
	
	the_system->system_font_ = the_font;
}


//! @param	the_system: valid pointer to system object
void Sys_SetAppFont(System* the_system, Font* the_font)
{
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return;
	}
	
	the_system->app_font_ = the_font;
}


//! @param	the_system: valid pointer to system object
void Sys_SetScreen(System* the_system, int16_t channel_id, Screen* the_screen)
{
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return;
	}
	
	if (channel_id != ID_CHANNEL_A && channel_id != ID_CHANNEL_B)
	{
		LOG_ERR(("%s %d: passed channel_id (%i) was invalid", __func__ , __LINE__, channel_id));
		return;
	}
	
	the_system->screen_[channel_id] = the_screen;
}


//! NOTE: Foenix systems only have 1 screen with bitmap graphics, even if the system has 2 screens overall. The bitmap returned will always be from the appropriate channel (A or B).
//! @param	the_system: valid pointer to system object
void Sys_SetScreenBitmap(System* the_system, Bitmap* the_bitmap, bitmap_layer the_layer)
{
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return;
	}
	
	if (the_bitmap == NULL)
	{
		LOG_WARN(("%s %d: passed bitmap object was null", __func__ , __LINE__));
		return;
	}
	
	if (the_layer > fore_layer)
	{
		LOG_ERR(("%s %d: passed layer (%i) was invalid", __func__ , __LINE__, the_layer));
		return;
	}
	
	the_system->screen_[ID_CHANNEL_B]->bitmap_[the_layer] = the_bitmap;
	
	Sys_SetVRAMAddr(the_system, the_layer, the_bitmap->addr_);
	
	DEBUG_OUT(("%s %d: layer=%i, bitmap_[the_layer]=%p", __func__, __LINE__, the_layer, the_bitmap->addr_));
}


//! Set the passed theme as the System's current theme
//! Note: this will dispose of the current theme after setting the new one
//! @param	the_system: valid pointer to system object
//! @return	Returns false on any error condition
bool Sys_SetTheme(System* the_system, Theme* the_theme)
{
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return false;
	}
	
	if (the_theme == NULL)
	{
		LOG_WARN(("%s %d: passed theme object was null", __func__ , __LINE__));
		return false;
	}
	
	if (the_system->theme_ != NULL)
	{
		Theme_Destroy(&the_system->theme_);
	}
	
	the_system->theme_ = the_theme;
	
	Sys_SetSystemFont(the_system, the_theme->control_font_);
	Sys_SetAppFont(the_system, the_theme->icon_font_);

	// have all windows update their controls / etc with info from new theme
	if (the_system->window_count_ > 0)
	{
		Sys_UpdateWindowTheme(the_system);
	
		// force re-render
		Sys_Render(the_system);
	}	
	
	return true;
}





// **** xxx functions *****


//! Tell the VICKY to use a different address for the specified bitmap layer
//! @param	the_system: valid pointer to system object
//! @param	the_bitmap_layer: 0 or 1, the bitmap layer to get a new address
//! @param	the_address: The address within the VRAM zone that the bitmap layer should be repointed to
bool Sys_SetVRAMAddr(System* the_system, uint8_t the_bitmap_layer, unsigned char* the_address)
{
	uint32_t			new_vicky_bitmap_vram_value;
	
	if (the_system == NULL)
	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return false;
	}
	
	if (the_bitmap_layer > 1)
	{
		LOG_ERR(("%s %d: passed bitmap layer number (%u) was invalid", __func__ , __LINE__, the_bitmap_layer));
		return false;
	}
	
	//DEBUG_OUT(("%s %d: VICKY VRAM for bitmap layer 0: want to point to bitmap at %p", __func__, __LINE__, the_address));

	//DEBUG_OUT(("%s %d: VICKY VRAM for bitmap layer 0 before change: 0x%x (with offset=0x%x)", __func__, __LINE__, R32(the_system->screen_[ID_CHANNEL_B]->vicky_ + BITMAP_L0_VRAM_ADDR_L), (uint32_t)VRAM_BUFFER_A + R32(the_system->screen_[ID_CHANNEL_B]->vicky_ + BITMAP_L0_VRAM_ADDR_L)));
	
	new_vicky_bitmap_vram_value = (uint32_t)the_address - (uint32_t)VRAM_BUFFER_A;		

// 	DEBUG_OUT(("%s %d: VICKY VRAM for bitmap layer 0 about to change to: 0x%x (with offset=0x%x)", __func__, __LINE__, new_vicky_bitmap_vram_value, (uint32_t)the_address));

	if (the_bitmap_layer == 0)
	{
		R32(the_system->screen_[ID_CHANNEL_B]->vicky_ + BITMAP_L0_VRAM_ADDR_L) = new_vicky_bitmap_vram_value;
	}
	else
	{
		R32(the_system->screen_[ID_CHANNEL_B]->vicky_ + BITMAP_L1_VRAM_ADDR_L) = new_vicky_bitmap_vram_value;
	}
	
	//DEBUG_OUT(("%s %d: VICKY VRAM for bitmap layer 0 now set to 0x%x (with offset=0x%x)", __func__, __LINE__, R32(the_system->screen_[ID_CHANNEL_B]->vicky_ + BITMAP_L0_VRAM_ADDR_L), (uint32_t)VRAM_BUFFER_A + R32(the_system->screen_[ID_CHANNEL_B]->vicky_ + BITMAP_L0_VRAM_ADDR_L)));

	return true;
}





// **** TEMP font loading *****

// create a font object and populate with modified chicago 14 pt regular
// this is a temporary function until we get file handling and can load from disk
Font* Sys_LoadSystemFont(void)
{
	unsigned char testFONTdata[] = { 
		0x90,0x01,0x00,0x00,0x00,0xD8,0x00,0x0E,0x00,0x00,
		0xFF,0xF4,0x00,0x0E,0x00,0x0F,0x04,0xDC,0x00,0x0C,
		0x00,0x03,0x00,0x01,0x00,0x44,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x0C,0x00,0x4C,0x80,0x00,0x00,
		0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x04,0x32,0xC8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x1F,0xC0,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,
		0x92,0x00,0x93,0x12,0x48,0x00,0x00,0x00,0x04,0x80,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x4D,0x30,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x0F,0x00,0x24,0x46,0xE0,0x00,0xC0,0x00,0x00,
		0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x01,0xE1,0xC0,0x01,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x70,0x00,0x12,0x00,0x00,0x00,
		0x00,0x42,0x0C,0x01,0x94,0x80,0x10,0x83,0x00,0x66,
		0x06,0x44,0x20,0xC0,0x19,0x10,0x83,0x00,0x00,0x40,
		0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC0,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x63,0x00,0x00,0x06,0x3A,0x24,
		0xE9,0x23,0xC5,0x22,0x00,0x00,0x17,0x9B,0xDF,0x86,
		0xFC,0xEF,0xDE,0x78,0x00,0x00,0x1E,0x00,0x3D,0xF3,
		0xDF,0x7F,0xEF,0x67,0x87,0x8F,0x10,0x0C,0x17,0xBE,
		0x7B,0xE7,0x7F,0x9E,0x79,0x9E,0x79,0xFF,0xA0,0xC8,
		0x00,0x80,0xC0,0x01,0x80,0x70,0x30,0xC7,0x86,0x00,
		0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,
		0xA8,0x07,0x9E,0x7B,0xF0,0x5E,0xCC,0x81,0x12,0x4A,
		0x63,0x00,0x20,0x44,0x92,0x99,0x99,0x88,0x11,0x24,
		0xA6,0x20,0x44,0x92,0x4C,0xE3,0x91,0x03,0xF3,0xC7,
		0x87,0x9D,0x13,0x20,0x1F,0xE3,0xD0,0x00,0x00,0x06,
		0x18,0x00,0x1F,0xFF,0xC0,0x06,0xE7,0x1E,0x00,0x00,
		0x06,0x60,0x01,0x0C,0x00,0x00,0x00,0x00,0x0F,0x3C,
		0xF3,0xFC,0x00,0x00,0x04,0xED,0xC0,0x01,0x27,0xF8,
		0x94,0x80,0x44,0x0C,0x3A,0xFF,0x59,0x46,0x67,0x3A,
		0x80,0x00,0x2C,0xFC,0x63,0x0E,0xC1,0x80,0xF3,0xCC,
		0x06,0x06,0x23,0x3E,0x67,0x9E,0x39,0xE3,0x18,0xE7,
		0x87,0x9B,0x18,0x1E,0x1C,0xF3,0xCF,0x3C,0x99,0x9E,
		0x79,0x9E,0x79,0x87,0x90,0xD4,0x00,0x40,0xC0,0x01,
		0x80,0xC0,0x30,0x01,0x86,0x00,0x00,0x00,0x00,0x00,
		0x0C,0x00,0x00,0x00,0x00,0x00,0xA8,0x0C,0xF3,0xC7,
		0x18,0x73,0xCC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0xF3,0x56,0x58,0x06,0x56,0x68,0x48,0x49,0xB4,0x00,
		0x33,0x06,0x60,0x00,0x00,0x03,0x30,0x03,0x8C,0x59,
		0x80,0x2D,0x3D,0xB3,0x00,0x00,0x06,0x60,0x02,0x18,
		0x01,0x00,0x00,0x00,0x19,0xE7,0x9E,0x60,0x00,0x00,
		0x09,0x6E,0xC0,0x20,0x04,0x08,0x94,0x80,0xCE,0x0F,
		0x3A,0x49,0xC6,0x46,0x6F,0x37,0x10,0x00,0x2C,0xD8,
		0x66,0x16,0xC3,0x00,0xF3,0xCF,0xCC,0x03,0x03,0x41,
		0x67,0x9E,0x19,0xE3,0x18,0x67,0x87,0xB3,0x1C,0x3F,
		0x1C,0xF3,0xCF,0x3C,0x19,0x9E,0x79,0x9E,0x79,0x87,
		0x90,0xE2,0x00,0x1E,0xF9,0xCF,0xBD,0xE7,0xFE,0xC7,
		0x9F,0xFF,0x7C,0xF7,0xCF,0xED,0xDF,0x9E,0x79,0x9E,
		0x79,0xFE,0xA9,0x9C,0xF3,0xC3,0x1C,0x73,0xCD,0xE7,
		0x9E,0x79,0xE7,0x9E,0x79,0xE7,0x9E,0xF6,0x6F,0x9E,
		0x79,0xE7,0x9E,0xCF,0x3C,0xF3,0x53,0x46,0x0C,0x76,
		0x56,0x77,0x33,0x29,0x58,0x01,0x33,0x06,0x67,0x1E,
		0x21,0x27,0xFB,0x30,0xC6,0x19,0x9F,0xCC,0xFD,0xE1,
		0xBF,0xC7,0xA0,0x00,0x02,0x18,0x11,0x02,0x64,0x00,
		0x19,0xE7,0x9E,0x61,0xFE,0x00,0x0D,0xA7,0x48,0x53,
		0x34,0x08,0x7F,0x01,0x9F,0x3C,0x30,0x49,0xC0,0x83,
		0x0B,0x3A,0x90,0x00,0x4C,0xD8,0x6F,0x26,0xFB,0xE0,
		0xF3,0xCF,0xD9,0xF9,0x86,0x9C,0xE7,0x9E,0x19,0xE3,
		0x18,0x67,0x87,0xE3,0x1E,0x7F,0x9C,0xF3,0xCF,0x3E,
		0x19,0x9E,0x79,0x9E,0x79,0x8D,0x88,0xC0,0x00,0x23,
		0xCF,0x39,0xE6,0xCC,0xF3,0xC7,0xB7,0x99,0xE7,0x9E,
		0x79,0xF3,0x2D,0x9E,0x79,0x9E,0x79,0x86,0xAA,0x6C,
		0xF3,0xC3,0x1E,0x73,0xCE,0x38,0xE3,0x8E,0x38,0xF1,
		0xCF,0x3C,0xF3,0xF6,0x6C,0xF3,0xCF,0x3C,0xF3,0xCF,
		0x3C,0xF3,0x4D,0x46,0x16,0xFE,0x56,0xD4,0xB4,0xA9,
		0x10,0x1F,0xF3,0x06,0xE8,0xB1,0x22,0x10,0xC3,0x31,
		0xE3,0x19,0xAC,0xCD,0xBD,0xE1,0xC6,0x6C,0xC6,0x60,
		0x44,0x3D,0xE2,0x84,0x92,0x00,0x19,0xE7,0x9E,0x63,
		0x33,0x00,0x0D,0xCB,0x80,0x8B,0x34,0x08,0x14,0x03,
		0x3F,0x98,0x31,0xFC,0xE0,0x86,0x73,0x32,0x7C,0xF8,
		0x4C,0xD8,0xC1,0xC6,0x0F,0x31,0x9E,0xCC,0x30,0x00,
		0xCC,0xA4,0xFF,0xF6,0x19,0xFB,0xDB,0xFF,0x87,0xC3,
		0x17,0xDD,0xDC,0xFE,0xCF,0xE7,0x19,0x9E,0x79,0x9B,
		0xCF,0x19,0x88,0xC0,0x00,0x1F,0xCF,0x19,0xE6,0xCC,
		0xF3,0xC7,0xE7,0x99,0xE7,0x9E,0x79,0xE3,0x8D,0x9E,
		0x79,0x9E,0x79,0x8D,0x24,0x0F,0xFF,0xC3,0xD7,0x73,
		0xCD,0xF7,0xDF,0x7D,0xF7,0xF0,0xCF,0x3C,0xF3,0xF6,
		0x6C,0xF3,0xCF,0x3C,0xF3,0xCF,0x3C,0xF3,0x41,0x5F,
		0x13,0xFB,0xD6,0x77,0x34,0x20,0x00,0x02,0x3F,0xC7,
		0x68,0x61,0xFC,0x0F,0xFB,0x33,0x61,0x99,0x8C,0xCD,
		0xBD,0xE1,0xBE,0x6C,0xC6,0x7F,0xC4,0x1A,0x12,0x89,
		0x09,0x00,0x1F,0xFF,0x9E,0x7B,0x33,0xFF,0xF0,0x00,
		0x3F,0x07,0x34,0x08,0x7F,0x46,0x1F,0x30,0x30,0x90,
		0x71,0x36,0x63,0x30,0x10,0x00,0x8C,0xD9,0x81,0xFF,
		0x0F,0x33,0x33,0x7C,0x19,0xF9,0x8C,0xA4,0xE7,0x9E,
		0x19,0xE3,0x19,0xE7,0xE7,0xE3,0x13,0x9C,0xFC,0xF0,
		0xCF,0x33,0x99,0x9E,0x79,0x9E,0x66,0x31,0x84,0xC0,
		0x00,0x33,0xCF,0x19,0xFE,0xCC,0xF3,0xC7,0xC7,0x99,
		0xE7,0x9E,0x79,0xE1,0xCD,0x9E,0x79,0x9B,0xD9,0x98,
		0xA8,0x0C,0xF3,0xC3,0x13,0xF3,0xCF,0x3C,0xF3,0xCF,
		0x3C,0xF0,0xFF,0xFF,0xFF,0xF6,0x6C,0xF3,0xCF,0x3C,
		0xF3,0xCF,0x3C,0xF3,0x00,0xE6,0x19,0xF8,0x56,0x74,
		0xB4,0xA0,0x00,0x1F,0xF3,0x06,0x68,0xD1,0x22,0x10,
		0xC3,0x36,0x63,0x19,0x8C,0xCC,0xF7,0x21,0x67,0xED,
		0xCC,0x61,0x28,0x19,0xE4,0x52,0x04,0x80,0x19,0xE7,
		0x9E,0x63,0x3F,0x00,0x00,0x00,0x00,0x8B,0x34,0x08,
		0x94,0xEC,0x0E,0x30,0x00,0x90,0x71,0x4E,0x63,0x30,
		0x10,0x00,0x8C,0xDB,0x01,0x86,0x0F,0x33,0x33,0x0C,
		0x0C,0x03,0x00,0x9B,0x67,0x9E,0x19,0xE3,0x19,0xE7,
		0xE7,0xB3,0x11,0x1C,0x7C,0xF0,0xCF,0x31,0x99,0x9E,
		0x79,0x9E,0x66,0x61,0x84,0xC0,0x00,0x33,0xCF,0x19,
		0xE0,0xCC,0xF3,0xC7,0xE7,0x99,0xE7,0x9E,0x79,0xE0,
		0xED,0x9E,0x79,0x9E,0x79,0xB0,0xA8,0x0C,0xF3,0xC3,
		0x11,0xF3,0xCF,0x3C,0xF3,0xCF,0x3C,0xF0,0xC3,0x0C,
		0x30,0xF6,0x6C,0xF3,0xCF,0x3C,0xF3,0xCF,0x3C,0xF3,
		0x00,0x46,0x0D,0x70,0x56,0x74,0xB3,0x20,0x00,0x04,
		0x33,0x06,0x67,0x8E,0x21,0x20,0xC3,0x36,0x66,0x19,
		0x8C,0xCC,0x00,0x12,0x66,0x0E,0xD8,0x61,0x28,0x1A,
		0x04,0x49,0x09,0x00,0x19,0xE7,0x9E,0x63,0x30,0x00,
		0x00,0x00,0x08,0x53,0x34,0x08,0x94,0xB8,0x04,0x60,
		0x30,0x01,0x52,0x4E,0x63,0x30,0x03,0x07,0x0C,0xDE,
		0x11,0x86,0x8F,0x33,0x33,0x1B,0xC6,0x06,0x0C,0x40,
		0x67,0x9E,0x39,0xE3,0x19,0xE7,0xE7,0x9B,0x10,0x1C,
		0x3C,0xF0,0xCF,0x39,0x99,0x9E,0x59,0x96,0x66,0x61,
		0x82,0xC0,0x00,0x33,0xCF,0x39,0xE2,0xCC,0xF3,0xC7,
		0xB7,0x99,0xE7,0x9E,0x79,0xE2,0x6D,0x9E,0x59,0x96,
		0x79,0xE0,0xA8,0x0C,0xF3,0xC7,0x10,0xF3,0xCF,0x3C,
		0xF3,0xCF,0x3C,0xF1,0xC7,0x1C,0x71,0xF6,0x6C,0xF3,
		0xCF,0x3C,0xF3,0xCF,0x3C,0xF3,0x00,0x06,0x26,0x00,
		0x56,0x68,0x48,0x40,0x00,0x00,0x33,0x0E,0x60,0x00,
		0x00,0x00,0xC3,0x36,0x4C,0x59,0x8C,0xCD,0xFF,0x92,
		0x66,0x2C,0xD8,0xE0,0x10,0x18,0x08,0x24,0x92,0x66,
		0x79,0xE7,0x9E,0x63,0x31,0x00,0x00,0x00,0x00,0x23,
		0x34,0x08,0x63,0x10,0x00,0x40,0x30,0x00,0xE2,0x33,
		0xC1,0x20,0x03,0x07,0x07,0x9F,0xEF,0x06,0x79,0xE3,
		0x1E,0x73,0xC0,0x00,0x0C,0x3E,0x67,0xF3,0xDF,0x7F,
		0x0F,0x67,0xBD,0x8F,0xF0,0x1C,0x17,0xB0,0x7B,0x37,
		0x18,0xF7,0x9F,0xE6,0x66,0x7F,0x82,0xC1,0xFE,0x1F,
		0xF9,0xCF,0xBC,0xC7,0xF3,0xC7,0x9F,0x99,0xE6,0xF7,
		0xCF,0xE1,0xC6,0xFF,0x9F,0xE6,0x6F,0xFE,0xA8,0x0C,
		0xF3,0x7B,0xF0,0x5E,0x79,0xF7,0xDF,0x7D,0xF7,0xDE,
		0x79,0xE7,0x9E,0xF6,0x6C,0xDE,0x79,0xE7,0x9E,0x7D,
		0xF7,0xDF,0x00,0x0F,0xC3,0x00,0x5E,0xC7,0x87,0x80,
		0x00,0x00,0x33,0xF3,0xC0,0x00,0xFF,0xF8,0xC3,0xEB,
		0x9F,0xD9,0x88,0x8C,0x00,0x33,0x3F,0xD7,0x8F,0x60,
		0x10,0x18,0x0F,0xE2,0x64,0x66,0x79,0xE6,0xF3,0xFD,
		0xFE,0x00,0x00,0x00,0x00,0x01,0xF4,0x08,0x00,0x00,
		0x00,0x00,0x00,0x00,0x40,0x00,0x00,0xC0,0x01,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,
		0x00,0x01,0xC1,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,
		0xC0,0x06,0x00,0x00,0x00,0x06,0x01,0x80,0x00,0x00,
		0x00,0x00,0x01,0x80,0x70,0x00,0x00,0x30,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x0C,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x37,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x08,0xC0,0x26,0x00,0x00,
		0x00,0x06,0x01,0x80,0x00,0x00,0x00,0x00,0x11,0x80,
		0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x04,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x30,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x07,0x80,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x0F,0x00,0x00,0x00,0x00,0x20,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x01,0xE0,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x09,0x00,0x12,0x00,0x19,0x00,0x22,
		0x00,0x22,0x00,0x22,0x00,0x22,0x00,0x22,0x00,0x22,
		0x00,0x22,0x00,0x22,0x00,0x22,0x00,0x22,0x00,0x22,
		0x00,0x22,0x00,0x22,0x00,0x24,0x00,0x27,0x00,0x2F,
		0x00,0x34,0x00,0x3D,0x00,0x45,0x00,0x46,0x00,0x49,
		0x00,0x4C,0x00,0x51,0x00,0x56,0x00,0x58,0x00,0x5D,
		0x00,0x5F,0x00,0x64,0x00,0x6A,0x00,0x6D,0x00,0x73,
		0x00,0x79,0x00,0x80,0x00,0x86,0x00,0x8C,0x00,0x92,
		0x00,0x98,0x00,0x9E,0x00,0xA0,0x00,0xA2,0x00,0xA7,
		0x00,0xAD,0x00,0xB2,0x00,0xB8,0x00,0xC1,0x00,0xC7,
		0x00,0xCD,0x00,0xD3,0x00,0xD9,0x00,0xDE,0x00,0xE3,
		0x00,0xE9,0x00,0xEF,0x00,0xF1,0x00,0xF7,0x00,0xFE,
		0x01,0x03,0x01,0x0D,0x01,0x14,0x01,0x1A,0x01,0x20,
		0x01,0x26,0x01,0x2C,0x01,0x31,0x01,0x37,0x01,0x3D,
		0x01,0x43,0x01,0x4D,0x01,0x53,0x01,0x59,0x01,0x5F,
		0x01,0x62,0x01,0x67,0x01,0x6A,0x01,0x6F,0x01,0x77,
		0x01,0x7A,0x01,0x80,0x01,0x86,0x01,0x8B,0x01,0x91,
		0x01,0x97,0x01,0x9C,0x01,0xA2,0x01,0xA8,0x01,0xAA,
		0x01,0xAF,0x01,0xB5,0x01,0xB7,0x01,0xC1,0x01,0xC7,
		0x01,0xCD,0x01,0xD3,0x01,0xD9,0x01,0xDE,0x01,0xE3,
		0x01,0xE7,0x01,0xED,0x01,0xF3,0x01,0xFD,0x02,0x03,
		0x02,0x09,0x02,0x0F,0x02,0x12,0x02,0x13,0x02,0x16,
		0x02,0x1C,0x02,0x1C,0x02,0x22,0x02,0x28,0x02,0x2E,
		0x02,0x33,0x02,0x3A,0x02,0x40,0x02,0x46,0x02,0x4C,
		0x02,0x52,0x02,0x58,0x02,0x5E,0x02,0x64,0x02,0x6A,
		0x02,0x70,0x02,0x76,0x02,0x7C,0x02,0x82,0x02,0x88,
		0x02,0x8A,0x02,0x8C,0x02,0x90,0x02,0x94,0x02,0x9A,
		0x02,0xA0,0x02,0xA6,0x02,0xAC,0x02,0xB2,0x02,0xB8,
		0x02,0xBE,0x02,0xC4,0x02,0xCA,0x02,0xD0,0x02,0xD3,
		0x02,0xD7,0x02,0xDC,0x02,0xE3,0x02,0xE8,0x02,0xED,
		0x02,0xF4,0x02,0xFB,0x03,0x03,0x03,0x0B,0x03,0x14,
		0x03,0x17,0x03,0x1B,0x03,0x22,0x03,0x2B,0x03,0x34,
		0x03,0x40,0x03,0x45,0x03,0x49,0x03,0x4D,0x03,0x55,
		0x03,0x5D,0x03,0x63,0x03,0x6A,0x03,0x72,0x03,0x7B,
		0x03,0x7F,0x03,0x84,0x03,0x89,0x03,0x91,0x03,0x9B,
		0x03,0xA3,0x03,0xA9,0x03,0xAB,0x03,0xB0,0x03,0xBA,
		0x03,0xBE,0x03,0xC4,0x03,0xCB,0x03,0xD2,0x03,0xD9,
		0x03,0xE3,0x03,0xE3,0x03,0xE9,0x03,0xEF,0x03,0xF5,
		0x03,0xFE,0x04,0x08,0x04,0x0C,0x04,0x14,0x04,0x19,
		0x04,0x1E,0x04,0x20,0x04,0x22,0x04,0x27,0x04,0x2E,
		0x04,0x34,0x04,0x3E,0x00,0x00,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0x08,0x08,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0x0B,
		0x01,0x0B,0x01,0x09,0x01,0x0B,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x04,0x04,
		0x02,0x06,0x02,0x07,0x01,0x0A,0x01,0x07,0x01,0x0B,
		0x01,0x0A,0x01,0x03,0x01,0x05,0x01,0x05,0x01,0x07,
		0x01,0x07,0x01,0x04,0x01,0x07,0x01,0x04,0x01,0x07,
		0x01,0x08,0x02,0x08,0x01,0x08,0x01,0x08,0x01,0x08,
		0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x08,
		0x01,0x04,0x01,0x04,0x00,0x06,0x01,0x08,0x00,0x06,
		0x01,0x08,0x01,0x0B,0x01,0x08,0x01,0x08,0x01,0x08,
		0x01,0x08,0x01,0x07,0x01,0x07,0x01,0x08,0x01,0x08,
		0x02,0x06,0x00,0x07,0x01,0x09,0x01,0x07,0x01,0x0C,
		0x01,0x09,0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x08,
		0x01,0x07,0x00,0x06,0x01,0x08,0x01,0x08,0x01,0x0C,
		0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x05,0x01,0x07,
		0x01,0x05,0x02,0x08,0x00,0x08,0x01,0x06,0x01,0x08,
		0x01,0x08,0x01,0x07,0x01,0x08,0x01,0x08,0x01,0x06,
		0x01,0x08,0x01,0x08,0x01,0x04,0x00,0x06,0x01,0x08,
		0x01,0x04,0x01,0x0C,0x01,0x08,0x01,0x08,0x01,0x08,
		0x01,0x08,0x01,0x06,0x01,0x07,0x01,0x06,0x01,0x08,
		0x01,0x08,0x01,0x0C,0x01,0x08,0x01,0x08,0x01,0x08,
		0x01,0x05,0x02,0x05,0x01,0x05,0x01,0x08,0x08,0x08,
		0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x07,0x01,0x09,
		0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x08,
		0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x08,
		0x01,0x08,0x01,0x08,0x01,0x08,0x02,0x06,0x02,0x06,
		0x01,0x06,0x01,0x06,0x01,0x08,0x01,0x08,0x01,0x08,
		0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x08,
		0x01,0x08,0x01,0x08,0x01,0x05,0x01,0x06,0x01,0x07,
		0x01,0x09,0x01,0x07,0x01,0x07,0x01,0x09,0x01,0x09,
		0x01,0x0A,0x01,0x0A,0x01,0x0B,0x01,0x05,0x01,0x06,
		0x01,0x09,0x01,0x0B,0x00,0x09,0x01,0x0E,0x01,0x07,
		0x01,0x06,0x01,0x06,0x01,0x0A,0x01,0x0A,0x01,0x08,
		0x01,0x09,0x01,0x0A,0x01,0x0B,0x01,0x06,0x01,0x07,
		0x01,0x07,0x01,0x0A,0x01,0x0C,0x00,0x08,0x01,0x08,
		0x02,0x06,0x01,0x07,0x01,0x0C,0x01,0x06,0x02,0x0A,
		0x01,0x09,0x01,0x09,0x01,0x09,0x02,0x0E,0x08,0x08,
		0x01,0x08,0x01,0x08,0x01,0x08,0x01,0x0B,0x01,0x0C,
		0x01,0x06,0x01,0x0A,0x01,0x07,0x01,0x07,0x01,0x04,
		0x01,0x04,0x01,0x07,0x01,0x09,0x01,0x08,0x00,0x0A,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x09,0x04,0x08,
		0x04,0x07,0x01,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x09,
		0x03,0x03,0x02,0x08,0x02,0x0B,0x02,0x0A,0x03,0x09,
		0x03,0x03,0x02,0x0B,0x02,0x0B,0x03,0x05,0x05,0x05,
		0x0A,0x04,0x07,0x01,0x0A,0x02,0x02,0x0A,0x03,0x09,
		0x03,0x09,0x03,0x09,0x03,0x09,0x03,0x09,0x03,0x09,
		0x03,0x09,0x03,0x09,0x03,0x09,0x03,0x09,0x05,0x07,
		0x05,0x09,0x04,0x07,0x06,0x03,0x04,0x07,0x03,0x09,
		0x04,0x08,0x03,0x09,0x03,0x09,0x03,0x09,0x03,0x09,
		0x03,0x09,0x03,0x09,0x03,0x09,0x03,0x09,0x03,0x09,
		0x03,0x09,0x03,0x09,0x03,0x09,0x03,0x09,0x03,0x09,
		0x03,0x09,0x03,0x09,0x03,0x0A,0x03,0x09,0x03,0x09,
		0x03,0x09,0x03,0x09,0x03,0x09,0x03,0x09,0x03,0x09,
		0x03,0x09,0x03,0x09,0x02,0x0B,0x02,0x0A,0x02,0x0B,
		0x03,0x03,0x0B,0x01,0x02,0x03,0x05,0x07,0x03,0x09,
		0x05,0x07,0x03,0x09,0x05,0x07,0x03,0x09,0x05,0x0A,
		0x03,0x09,0x03,0x09,0x03,0x0C,0x03,0x09,0x03,0x09,
		0x05,0x07,0x05,0x07,0x05,0x07,0x05,0x09,0x05,0x09,
		0x05,0x07,0x05,0x07,0x03,0x09,0x05,0x07,0x05,0x07,
		0x05,0x07,0x05,0x07,0x05,0x0A,0x05,0x07,0x02,0x0B,
		0x02,0x0B,0x02,0x0B,0x05,0x02,0x00,0x00,0x01,0x0B,
		0x00,0x0C,0x03,0x0C,0x00,0x0C,0x00,0x0C,0x01,0x0B,
		0x01,0x0B,0x02,0x0A,0x02,0x0A,0x02,0x0A,0x03,0x09,
		0x02,0x0A,0x00,0x0C,0x05,0x0A,0x02,0x0A,0x02,0x0A,
		0x02,0x0A,0x03,0x09,0x02,0x0A,0x02,0x0A,0x02,0x0A,
		0x03,0x09,0x02,0x0A,0x02,0x0A,0x02,0x0A,0x02,0x0A,
		0x03,0x09,0x02,0x0A,0x02,0x0A,0x02,0x0A,0x02,0x0A,
		0x03,0x09,0x03,0x05,0x03,0x04,0x02,0x08,0x03,0x09,
		0x02,0x0C,0x05,0x05,0x03,0x09,0x03,0x09,0x03,0x09,
		0x03,0x09,0x03,0x04,0x03,0x03,0x03,0x01,0x05,0x05,
		0x03,0x09,0x03,0x09,0x05,0x05,0x05,0x07,0x05,0x07,
		0x05,0x07,0x03,0x09,0x05,0x09,0x04,0x08,0x03,0x09,
		0x03,0x09,0x04,0x08,0x03,0x0B,0x03,0x08,0x03,0x08,
		0x03,0x09,0x05,0x07,0x05,0x07,0x03,0x09,0x03,0x09,
		0x07,0x03,0x02,0x0A,0x03,0x0B,0x05,0x05,0x04,0x08,
		0x05,0x07,0x05,0x07,0x0A,0x02,0x00,0x00,0x00,0x0C,
		0x00,0x0C,0x00,0x0C,0x03,0x09,0x05,0x07,0x07,0x01,
		0x07,0x01,0x03,0x04,0x03,0x04,0x03,0x04,0x03,0x04,
		0x05,0x05,0x04,0x07,0x03,0x0C,0x03,0x0A,0x00,0x09,
	};
	
	unsigned char*	the_new_font_data = testFONTdata;
	Font*			the_font;

	if ( (the_font = Font_LoadFontData(the_new_font_data)) == NULL)
	{
		LOG_ERR(("%s %d: error condition on loading font data", __func__, __LINE__));
		return NULL;
	}
	else
	{
		DEBUG_OUT(("%s %d: font data loaded ok.", __func__, __LINE__));
		return the_font;
	}
}

// create a font object and populate with helvetica 9 pt regular
// this is a temporary function until we get file handling and can load from disk
Font* Sys_LoadAppFont(void)
{
	unsigned char helvetica9FONTdata[] = { 
		0x90,0x01,0x00,0x00,0x00,0xFF,0x00,0x09,0x00,0x00,
		0xFF,0xF8,0x00,0x08,0x00,0x0A,0x03,0x37,0x00,0x08,
		0x00,0x02,0x00,0x01,0x00,0x38,0x00,0x20,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x28,0x80,0x13,0x29,0x28,0x00,0x20,0x1A,0xC0,
		0x00,0x20,0x64,0x1A,0x48,0x40,0xD2,0x42,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x08,0x6B,0x40,0x00,0x00,0x00,0x00,0x00,0x02,
		0x80,0x00,0x00,0x00,0x02,0x10,0x4A,0x42,0xAC,0x11,
		0x80,0x20,0x22,0x20,0x00,0x00,0x0A,0x00,0xD5,0x66,
		0x2C,0xB2,0x00,0x0B,0x2C,0xC3,0xED,0xEC,0xC0,0x00,
		0x63,0xC2,0x78,0xDC,0xFF,0x9D,0x18,0xC6,0x20,0xE4,
		0xCE,0x33,0xCE,0xFC,0x63,0x26,0x31,0xFE,0xD0,0x20,
		0x40,0x08,0x21,0x1C,0x40,0x00,0x00,0x00,0x00,0x00,
		0x00,0x01,0xC6,0x91,0x46,0x26,0xC6,0x44,0x88,0x52,
		0xAD,0x20,0x24,0x59,0x9B,0x6C,0x84,0xB3,0x64,0x25,
		0x94,0x80,0x8C,0x3D,0x80,0x00,0x06,0x81,0xF3,0x40,
		0x00,0x22,0x00,0x0F,0xE0,0x3E,0x00,0x00,0x00,0x04,
		0x60,0x00,0x00,0x04,0xB5,0x86,0xE0,0x00,0x02,0xD5,
		0x00,0x54,0x60,0x0A,0xA8,0x04,0x27,0x28,0x9F,0x25,
		0xD2,0x61,0x83,0x19,0x5D,0xD4,0xAF,0x39,0x45,0xE0,
		0xD5,0xB9,0x52,0xCF,0x00,0x0C,0xF3,0x27,0x10,0x33,
		0x20,0x00,0x94,0x22,0x45,0x32,0x84,0x23,0x18,0xCA,
		0x31,0xE5,0x29,0x4A,0x31,0x24,0x63,0x25,0x51,0x1A,
		0x68,0x10,0x40,0x08,0x41,0x04,0x40,0x00,0x00,0x01,
		0x00,0x00,0x00,0x02,0xAB,0x10,0x89,0xFE,0x49,0x45,
		0x04,0x00,0x00,0xC0,0x42,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x05,0x45,0x52,0x6A,0x5E,0x7B,0xD8,0x01,
		0x84,0x80,0x00,0x14,0x05,0xF4,0x40,0x5E,0xE0,0x00,
		0x00,0x04,0xA0,0x40,0x00,0x04,0x22,0x49,0x80,0x00,
		0x02,0xD9,0x02,0x04,0x60,0x11,0x28,0x0A,0x42,0x7C,
		0x90,0xFC,0x92,0x92,0x42,0x25,0x18,0xC5,0x70,0xC1,
		0x41,0x20,0x8F,0xA9,0x94,0x4A,0x20,0x0C,0xA2,0x2B,
		0xDC,0x53,0x34,0x84,0x19,0xD2,0x46,0x11,0x84,0x41,
		0x18,0xD2,0x31,0xD6,0x19,0x86,0x30,0x24,0x55,0x55,
		0x4A,0x2A,0x40,0x06,0x73,0x3B,0x6F,0xDC,0xF6,0xA6,
		0xE7,0xAF,0xCC,0x6B,0x18,0xFA,0xA0,0x29,0x50,0x85,
		0x50,0xC5,0x8C,0x63,0x18,0xC6,0x66,0x66,0xA4,0xA8,
		0xCC,0xCC,0xC9,0x99,0x9F,0x5D,0x08,0x6A,0x61,0x85,
		0x70,0x0A,0x89,0x76,0x43,0x08,0x03,0x14,0x4F,0x41,
		0x17,0xCC,0x50,0x08,0x82,0x40,0x00,0x0A,0x54,0x30,
		0x8D,0x80,0x00,0x0A,0x22,0x8A,0xAC,0x1B,0xBC,0x0A,
		0x85,0x41,0x50,0x84,0x93,0x0C,0x2D,0xC3,0x18,0xC6,
		0x00,0x00,0x01,0x20,0x85,0x67,0xC8,0x48,0x20,0x14,
		0xA4,0x52,0x32,0x4D,0x21,0x7A,0x2A,0x55,0x7A,0x11,
		0xFF,0xCF,0xF8,0xE2,0x2A,0xD6,0x1E,0x87,0xCE,0x24,
		0x55,0x54,0x8A,0x69,0x40,0x09,0x4C,0xCC,0xD3,0x3D,
		0x69,0xD9,0x99,0xD1,0x4A,0xAA,0xA8,0x92,0xA0,0x29,
		0x50,0xFD,0x50,0xC6,0x52,0x94,0xA5,0x29,0x99,0x99,
		0xA4,0xB5,0x33,0x33,0x29,0x99,0x94,0xAB,0x95,0xEA,
		0xAD,0xB5,0x70,0x7A,0xFA,0x6A,0x44,0x9D,0x26,0x84,
		0x5A,0x5F,0x19,0x32,0x00,0x69,0xCC,0xA5,0xA0,0x0A,
		0x54,0x30,0xF2,0x40,0x00,0x00,0x05,0x8A,0xB2,0xD3,
		0x2A,0x05,0xA5,0x7D,0x5F,0xFC,0x93,0x0C,0x3F,0x43,
		0x18,0xC6,0x00,0x00,0x01,0x20,0x8F,0x33,0x35,0x48,
		0xF9,0xD4,0xA8,0x3E,0x32,0x92,0xE2,0x01,0x4A,0x57,
		0x46,0x11,0x84,0x43,0x1C,0xD2,0x2A,0xCE,0x18,0x96,
		0x21,0x24,0x48,0x89,0x44,0x49,0x40,0x07,0x4C,0x4F,
		0xD3,0x3E,0x69,0x99,0x99,0x8D,0x4A,0xAA,0x45,0x24,
		0x90,0x39,0xD0,0x84,0xD0,0xC5,0xCE,0x73,0x9C,0xE8,
		0xFF,0xFF,0xA4,0xA5,0x33,0x33,0x29,0x99,0x94,0x29,
		0x13,0xAA,0x6D,0xB4,0x00,0x17,0x8A,0x77,0xF8,0x49,
		0x2A,0x44,0x4A,0x41,0x17,0xF6,0x5F,0xB0,0x92,0xAA,
		0x50,0x0E,0x74,0x30,0x93,0xFF,0xFC,0x00,0xFD,0x51,
		0x33,0x33,0x28,0x03,0x57,0x41,0xD0,0x84,0x93,0x0C,
		0x3F,0xC3,0x18,0xC6,0x00,0x00,0x01,0x20,0x05,0xB5,
		0x32,0x48,0x20,0x14,0xB1,0x23,0x32,0x92,0x21,0x7A,
		0x09,0xA8,0xC5,0x32,0x84,0x27,0x1C,0xCA,0x24,0xCD,
		0x28,0x4A,0x31,0x24,0x48,0x89,0x44,0x89,0x40,0x09,
		0x4C,0xCC,0x53,0x3D,0x69,0x99,0x99,0x83,0x59,0x14,
		0xA5,0x42,0xA0,0x46,0x29,0x84,0xC9,0x46,0x52,0x94,
		0xA5,0x29,0x88,0x88,0xA4,0xA5,0x33,0x33,0x2B,0xBB,
		0xB4,0x29,0x2A,0x2A,0x61,0x84,0x00,0x7C,0x84,0x80,
		0x44,0x9D,0x2A,0x84,0x4A,0x40,0xA9,0x1A,0x90,0x90,
		0x8D,0x15,0xA0,0x11,0x8A,0x49,0x92,0x00,0x00,0x00,
		0x02,0x51,0x2C,0xD3,0x28,0x05,0x58,0xC2,0x30,0x84,
		0x92,0x92,0x5F,0xA5,0x18,0xC6,0x00,0x04,0x01,0x20,
		0x85,0x68,0xCD,0x48,0x22,0x33,0x3E,0xC2,0xCC,0x8C,
		0xD4,0x84,0x44,0x08,0xF8,0xDC,0xFC,0x1B,0x1B,0x47,
		0xE4,0xC4,0xC8,0x36,0x2E,0x23,0x88,0x8A,0x24,0xF9,
		0x40,0x06,0xF3,0x3B,0xCF,0x3C,0xE9,0x96,0xE7,0x9C,
		0xA9,0x15,0x12,0x7A,0xA0,0x46,0x26,0xFC,0x46,0x39,
		0xAD,0x6B,0x5A,0xD6,0x77,0x77,0xA4,0xA4,0xCC,0xCC,
		0xC5,0x55,0x54,0x1F,0xC4,0x2A,0x9E,0x78,0x00,0x24,
		0xFB,0x01,0xFF,0xC9,0xD5,0x14,0x4A,0x41,0xB6,0xED,
		0x10,0x90,0x91,0xF0,0x09,0x31,0x89,0x86,0xED,0xC0,
		0x00,0x00,0x22,0x21,0x20,0x13,0x3C,0xD8,0xA8,0xFE,
		0x3F,0xFC,0x92,0x61,0x8D,0x18,0xE7,0x3A,0x00,0x04,
		0x11,0xE0,0x00,0x20,0x00,0x48,0x02,0x00,0x00,0x00,
		0x00,0x00,0x04,0x00,0x03,0xE0,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x08,0x40,0x00,0x00,0x00,0x12,0x08,0x00,0x00,
		0x81,0x00,0x00,0x00,0x02,0x02,0xA0,0x00,0x04,0x00,
		0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x04,0x10,0x12,0x28,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x01,0x01,0xFE,0xE0,0x40,
		0x00,0x01,0x30,0x02,0x80,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x08,0xD0,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x02,0x20,0x00,0x00,0x00,0x00,0x30,0x04,0x00,
		0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x0C,0xC7,0xC0,0x00,0x00,0x0C,0x08,
		0x00,0x00,0x81,0x00,0x00,0x00,0x04,0x01,0xC0,0x00,
		0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x0C,0x28,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,
		0x00,0x80,0x00,0x00,0xD0,0x03,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,
		0x09,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x06,0x30,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x08,
		0x00,0x0C,0x00,0x13,0x00,0x18,0x00,0x19,0x00,0x1B,
		0x00,0x1D,0x00,0x20,0x00,0x25,0x00,0x27,0x00,0x2A,
		0x00,0x2B,0x00,0x2D,0x00,0x31,0x00,0x33,0x00,0x37,
		0x00,0x3B,0x00,0x3F,0x00,0x43,0x00,0x47,0x00,0x4B,
		0x00,0x4F,0x00,0x53,0x00,0x54,0x00,0x56,0x00,0x59,
		0x00,0x5D,0x00,0x60,0x00,0x64,0x00,0x6C,0x00,0x71,
		0x00,0x76,0x00,0x7B,0x00,0x80,0x00,0x85,0x00,0x89,
		0x00,0x8F,0x00,0x94,0x00,0x95,0x00,0x99,0x00,0x9E,
		0x00,0xA2,0x00,0xA9,0x00,0xAE,0x00,0xB4,0x00,0xB8,
		0x00,0xBE,0x00,0xC3,0x00,0xC8,0x00,0xCD,0x00,0xD2,
		0x00,0xD7,0x00,0xDE,0x00,0xE3,0x00,0xE8,0x00,0xEC,
		0x00,0xEE,0x00,0xF0,0x00,0xF2,0x00,0xF5,0x00,0xFA,
		0x00,0xFC,0x01,0x01,0x01,0x05,0x01,0x09,0x01,0x0D,
		0x01,0x11,0x01,0x13,0x01,0x17,0x01,0x1B,0x01,0x1C,
		0x01,0x1D,0x01,0x21,0x01,0x22,0x01,0x28,0x01,0x2C,
		0x01,0x30,0x01,0x34,0x01,0x38,0x01,0x3B,0x01,0x3F,
		0x01,0x41,0x01,0x45,0x01,0x4A,0x01,0x4F,0x01,0x54,
		0x01,0x59,0x01,0x5D,0x01,0x60,0x01,0x61,0x01,0x64,
		0x01,0x69,0x01,0x69,0x01,0x6E,0x01,0x73,0x01,0x78,
		0x01,0x7D,0x01,0x83,0x01,0x89,0x01,0x8E,0x01,0x93,
		0x01,0x98,0x01,0x9D,0x01,0xA2,0x01,0xA7,0x01,0xAC,
		0x01,0xB0,0x01,0xB4,0x01,0xB8,0x01,0xBC,0x01,0xC0,
		0x01,0xC2,0x01,0xC4,0x01,0xC7,0x01,0xCA,0x01,0xCF,
		0x01,0xD3,0x01,0xD7,0x01,0xDB,0x01,0xDF,0x01,0xE4,
		0x01,0xE8,0x01,0xEC,0x01,0xF0,0x01,0xF4,0x01,0xF7,
		0x01,0xFA,0x01,0xFE,0x02,0x03,0x02,0x07,0x02,0x09,
		0x02,0x0E,0x02,0x12,0x02,0x18,0x02,0x1E,0x02,0x24,
		0x02,0x26,0x02,0x29,0x02,0x2D,0x02,0x34,0x02,0x3A,
		0x02,0x3F,0x02,0x44,0x02,0x47,0x02,0x4A,0x02,0x4F,
		0x02,0x54,0x02,0x57,0x02,0x5C,0x02,0x63,0x02,0x68,
		0x02,0x6B,0x02,0x6D,0x02,0x6F,0x02,0x74,0x02,0x7B,
		0x02,0x7F,0x02,0x83,0x02,0x84,0x02,0x89,0x02,0x8E,
		0x02,0x93,0x02,0x97,0x02,0x9C,0x02,0xA0,0x02,0xA4,
		0x02,0xAB,0x02,0xAB,0x02,0xB0,0x02,0xB5,0x02,0xBB,
		0x02,0xC3,0x02,0xCA,0x02,0xCE,0x02,0xD6,0x02,0xD9,
		0x02,0xDC,0x02,0xDE,0x02,0xE0,0x02,0xE5,0x02,0xE8,
		0x02,0xED,0x02,0xF2,0x02,0xF3,0x02,0xF7,0x02,0xF9,
		0x02,0xFB,0x02,0xFF,0x03,0x03,0x03,0x06,0x03,0x07,
		0x03,0x09,0x03,0x0C,0x03,0x14,0x03,0x19,0x03,0x1E,
		0x03,0x23,0x03,0x28,0x03,0x2D,0x03,0x2F,0x03,0x32,
		0x03,0x35,0x03,0x37,0x03,0x3D,0x03,0x43,0x03,0x49,
		0x03,0x4F,0x03,0x54,0x03,0x59,0x03,0x5E,0x03,0x5F,
		0x03,0x62,0x03,0x65,0x03,0x67,0x03,0x6B,0x03,0x6C,
		0x03,0x6D,0x03,0x6F,0x03,0x72,0x03,0x74,0x03,0x77,
		0x03,0x7C,0x00,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0x00,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x02,0x01,0x03,
		0x00,0x03,0x00,0x05,0x00,0x05,0x00,0x08,0x00,0x06,
		0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x04,0x00,0x05,
		0x00,0x03,0x00,0x03,0x01,0x03,0x00,0x03,0x00,0x05,
		0x01,0x05,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x05,
		0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x05,0x01,0x03,
		0x00,0x03,0x01,0x05,0x00,0x05,0x01,0x05,0x00,0x05,
		0x00,0x09,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,
		0x00,0x06,0x00,0x05,0x00,0x07,0x00,0x06,0x01,0x03,
		0x00,0x05,0x00,0x06,0x00,0x05,0x00,0x07,0x00,0x06,
		0x00,0x07,0x01,0x06,0x00,0x07,0x00,0x06,0x00,0x06,
		0x00,0x05,0x00,0x06,0x00,0x06,0x00,0x08,0x00,0x06,
		0x00,0x06,0x00,0x05,0x00,0x03,0x00,0x03,0x00,0x03,
		0x00,0x04,0x00,0x05,0x00,0x03,0x00,0x05,0x00,0x05,
		0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x03,0x00,0x05,
		0x00,0x05,0x00,0x02,0x00,0x02,0x00,0x05,0x00,0x02,
		0x00,0x07,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x05,
		0x00,0x03,0x00,0x05,0x00,0x03,0x00,0x05,0x00,0x05,
		0x00,0x06,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x03,
		0x00,0x02,0x00,0x03,0x00,0x05,0xFF,0xFF,0x00,0x06,
		0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x07,
		0x00,0x06,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x05,
		0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x05,
		0x00,0x05,0x00,0x05,0x00,0x02,0x00,0x02,0x00,0x03,
		0x00,0x03,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x05,
		0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x05,
		0x00,0x05,0x01,0x05,0x00,0x03,0x00,0x05,0x00,0x05,
		0x00,0x05,0x00,0x03,0x00,0x05,0x00,0x05,0x00,0x07,
		0x00,0x07,0x01,0x08,0x00,0x03,0x00,0x03,0x00,0x05,
		0x01,0x09,0x00,0x07,0x00,0x06,0x00,0x05,0x01,0x05,
		0x01,0x05,0x00,0x05,0x00,0x05,0x00,0x04,0x00,0x06,
		0x00,0x08,0x00,0x05,0x00,0x03,0x00,0x03,0x00,0x03,
		0x01,0x07,0x00,0x08,0x00,0x05,0x00,0x05,0x01,0x03,
		0x00,0x06,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x06,
		0x00,0x05,0x00,0x05,0x01,0x09,0x00,0x05,0x00,0x06,
		0x00,0x06,0x00,0x07,0x00,0x09,0x00,0x08,0x00,0x05,
		0x00,0x09,0x00,0x03,0x00,0x03,0x00,0x02,0x00,0x02,
		0x00,0x05,0x00,0x04,0x00,0x05,0x00,0x06,0x00,0x02,
		0x00,0x05,0x00,0x03,0x00,0x03,0x00,0x05,0x00,0x05,
		0x01,0x05,0x01,0x03,0x00,0x02,0x00,0x03,0x00,0x09,
		0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,
		0x01,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x07,
		0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x06,0x00,0x06,
		0x00,0x06,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x03,
		0x00,0x04,0x01,0x03,0x01,0x03,0x00,0x03,0x00,0x03,
		0x00,0x03,0x01,0x05,0x00,0x05,0xFF,0xFF,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x01,0x07,0x01,0x02,0x01,0x07,
		0x00,0x09,0x01,0x07,0x01,0x07,0x01,0x02,0x01,0x09,
		0x01,0x09,0x01,0x03,0x03,0x05,0x07,0x03,0x05,0x01,
		0x07,0x01,0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,
		0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,
		0x01,0x07,0x01,0x07,0x03,0x05,0x03,0x07,0x03,0x05,
		0x04,0x03,0x03,0x05,0x01,0x07,0x01,0x08,0x01,0x07,
		0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,
		0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,
		0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,
		0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,
		0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,0x01,0x07,
		0x01,0x09,0x01,0x07,0x01,0x09,0x01,0x02,0x09,0x01,
		0x01,0x02,0x03,0x05,0x01,0x07,0x03,0x05,0x01,0x07,
		0x03,0x05,0x01,0x07,0x03,0x07,0x01,0x07,0x01,0x07,
		0x01,0x09,0x01,0x07,0x01,0x07,0x03,0x05,0x03,0x05,
		0x03,0x05,0x03,0x07,0x03,0x07,0x03,0x05,0x03,0x05,
		0x02,0x06,0x03,0x05,0x03,0x05,0x03,0x05,0x03,0x05,
		0x03,0x07,0x03,0x05,0x01,0x09,0x01,0x09,0x01,0x09,
		0x01,0x02,0x00,0x00,0x00,0x08,0x00,0x08,0x01,0x09,
		0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x01,0x07,
		0x01,0x07,0x00,0x08,0x01,0x07,0x00,0x08,0x00,0x08,
		0x03,0x07,0x01,0x07,0x01,0x07,0x00,0x08,0x01,0x07,
		0x00,0x08,0x00,0x08,0x00,0x08,0x01,0x07,0x00,0x08,
		0x00,0x08,0x00,0x08,0x00,0x08,0x01,0x07,0x00,0x08,
		0x00,0x08,0x00,0x08,0x00,0x08,0x01,0x07,0x01,0x09,
		0x01,0x04,0x02,0x07,0x01,0x07,0x01,0x09,0x04,0x02,
		0x01,0x09,0x01,0x07,0x02,0x06,0x02,0x06,0x02,0x03,
		0x01,0x02,0x01,0x01,0x03,0x05,0x01,0x07,0x01,0x07,
		0x03,0x03,0x03,0x05,0x03,0x05,0x03,0x05,0x01,0x07,
		0x04,0x06,0x02,0x06,0x02,0x07,0x01,0x08,0x03,0x05,
		0x01,0x09,0x01,0x04,0x01,0x04,0x02,0x06,0x03,0x05,
		0x03,0x05,0x03,0x07,0x03,0x07,0x05,0x03,0x01,0x07,
		0x01,0x09,0x03,0x05,0x02,0x06,0x04,0x03,0x04,0x03,
		0x07,0x01,0x00,0x00,0x00,0x08,0x00,0x08,0x00,0x08,
		0x01,0x07,0x03,0x05,0x05,0x01,0x05,0x01,0x01,0x02,
		0x01,0x02,0x01,0x03,0x01,0x03,0x03,0x05,0x02,0x06,
		0x01,0x09,0x00,0x08,0x01,0x07,0x03,0x04,0x04,0x03,
		0x04,0x03,0x01,0x07,0x01,0x07,0x01,0x09,0x04,0x01,
		0x07,0x03,0x07,0x03,0x01,0x07,0x00,0x08,0x00,0x08,
		0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,
		0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x01,0x07,
		0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x03,0x05,
		0x01,0x02,0x01,0x02,0x01,0x01,0x01,0x02,0x01,0x01,
		0x01,0x01,0x06,0x04,0x01,0x02,0x07,0x03,0x00,0x02,
		0x01,0x07,0x54,0x75,
	};
		
	unsigned char*	the_new_font_data = helvetica9FONTdata;
	Font*			the_font;
		
	if ( (the_font = Font_LoadFontData(the_new_font_data)) == NULL)
	{
		LOG_ERR(("%s %d: error condition on loading font data", __func__, __LINE__));
		return NULL;
	}
	else
	{
		DEBUG_OUT(("%s %d: font data loaded ok.", __func__, __LINE__));
		return the_font;
	}
}


// **** Render functions *****


//! Render all visible windows
//! NOTE: this will move to a private Sys function later, once event handling is available
//! @param	the_system: valid pointer to system object
void Sys_Render(System* the_system)
{
	int16_t		num_nodes = 0;
	List*		the_item;

 	if (the_system == NULL)
 	{
		LOG_ERR(("%s %d: passed class object was null", __func__ , __LINE__));
		return;
 	}
	
	// LOGIC:
	//   as we do not have regions and layers set up yet, we have to render every single window in its entirely, including the backdrop
	//   therefore, it is critical that the rendering take place in the order of back to front
	//   display order is built into the system's window list: the first item is the foremost, and the last is the backmost
	//   need to render from back of list towards front of list, so they built up over each other in right order.
	
	// have each window (re)render its controls/content/etc to its bitmap, and blit itself to the main screen/backdrop window bitmap
	
	if (the_system->list_windows_ == NULL)
	{
		DEBUG_OUT(("%s %d: the window list was NULL", __func__ , __LINE__));
		return;
	}
	
	//List_Print(the_system->list_windows_, (void*)&Window_PrintBrief);
	the_item = List_GetLast(the_system->list_windows_);
	//the_item = *(the_system->list_windows_);

	while (the_item != NULL)
	{
		Window*		this_window = (Window*)(the_item->payload_);
		
		//DEBUG_OUT(("%s %d: rendering window '%s'", __func__ , __LINE__, this_window->title_));
		
		if (Window_IsVisible(this_window) == true)
		{
			++num_nodes;
			Window_Render(this_window);

// 			// blit to screen
// 			Bitmap_Blit(this_window->bitmap_, 0, 0, the_system->screen_[ID_CHANNEL_B]->bitmap_, this_window->x_, this_window->y_, this_window->width_, this_window->height_);
		}

		the_item = the_item->prev_item_;
	}

	//DEBUG_OUT(("%s %d: %i windows rendered out of %i total window", __func__ , __LINE__, num_nodes, the_system->window_count_));
}

