<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Foenix A2650 Text Mode Library: general.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Foenix A2650 Text Mode Library
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('general_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">general.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;mcp/syscalls.h&gt;</code><br />
<code>#include &lt;mb/a2560_platform.h&gt;</code><br />
</div>
<p><a href="general_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a99ff818a3807eebb3043279d6e6d479c"><td class="memItemLeft" align="right" valign="top"><a id="a99ff818a3807eebb3043279d6e6d479c" name="a99ff818a3807eebb3043279d6e6d479c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_STRING_COMP_LEN</b>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:a99ff818a3807eebb3043279d6e6d479c"><td class="mdescLeft">&#160;</td><td class="mdescRight">255 + terminator is max string size for compares <br /></td></tr>
<tr class="separator:a99ff818a3807eebb3043279d6e6d479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016d1badf70ac5e79aad36d0f1e811d3"><td class="memItemLeft" align="right" valign="top"><a id="a016d1badf70ac5e79aad36d0f1e811d3" name="a016d1badf70ac5e79aad36d0f1e811d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GEN_NO_STRLEN_CAP</b>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:a016d1badf70ac5e79aad36d0f1e811d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">for the xxx_DrawString function's max_chars parameter, the value that corresponds to 'draw the entire string if it fits, do not cap it at n characters' <br /></td></tr>
<tr class="separator:a016d1badf70ac5e79aad36d0f1e811d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac005de778a95d82fbf99f51b4ec1b8d7"><td class="memItemLeft" align="right" valign="top"><a id="ac005de778a95d82fbf99f51b4ec1b8d7" name="ac005de778a95d82fbf99f51b4ec1b8d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WORD_WRAP_MAX_LEN</b>&#160;&#160;&#160;12800</td></tr>
<tr class="memdesc:ac005de778a95d82fbf99f51b4ec1b8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the xxx_DrawStringInBox function, the strnlen char limit. 128*100 (1024x768 with 8x8 char grid). <br /></td></tr>
<tr class="separator:ac005de778a95d82fbf99f51b4ec1b8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac9d5562510f9cb5809bc5e5b640f07a8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#ac9d5562510f9cb5809bc5e5b640f07a8">General_WrapAndTrimTextToFit</a> (char **orig_string, char **formatted_string, int16_t max_chars_to_format, int16_t max_width, int16_t max_height, int16_t one_char_width, int16_t one_row_height, <a class="el" href="struct_font.html">Font</a> *the_font, int16_t(*measure_function)(<a class="el" href="struct_font.html">Font</a> *, char *, int16_t, int16_t, int16_t, int16_t *))</td></tr>
<tr class="memdesc:ac9d5562510f9cb5809bc5e5b640f07a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a string by wrapping and trimming to fit the passed width and height.  <a href="general_8h.html#ac9d5562510f9cb5809bc5e5b640f07a8">More...</a><br /></td></tr>
<tr class="separator:ac9d5562510f9cb5809bc5e5b640f07a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d15a10ba145726c598611b6eb97cf0d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a6d15a10ba145726c598611b6eb97cf0d">General_Round</a> (double the_float)</td></tr>
<tr class="memdesc:a6d15a10ba145726c598611b6eb97cf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a float to the nearest integer value THINK C's and SAS/C's math.h don't include round() from: <a href="https://stackoverflow.com/questions/4572556/concise-way-to-implement-round-in-c">https://stackoverflow.com/questions/4572556/concise-way-to-implement-round-in-c</a>.  <a href="general_8h.html#a6d15a10ba145726c598611b6eb97cf0d">More...</a><br /></td></tr>
<tr class="separator:a6d15a10ba145726c598611b6eb97cf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1db800160346891a591a3525a25ef0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#ad1db800160346891a591a3525a25ef0c">General_StrToLower</a> (char *the_string)</td></tr>
<tr class="memdesc:ad1db800160346891a591a3525a25ef0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string, in place, to lower case This overwrites the string with a lower case version of itself.  <a href="general_8h.html#ad1db800160346891a591a3525a25ef0c">More...</a><br /></td></tr>
<tr class="separator:ad1db800160346891a591a3525a25ef0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ef78619dd4f8a5704da0c13892a3b7"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#aa9ef78619dd4f8a5704da0c13892a3b7">General_ToLower</a> (char the_char)</td></tr>
<tr class="memdesc:aa9ef78619dd4f8a5704da0c13892a3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the case of the passed character from upper to lower (if necessary) Scope is limited to characters A-Z, ascii.  <a href="general_8h.html#aa9ef78619dd4f8a5704da0c13892a3b7">More...</a><br /></td></tr>
<tr class="separator:aa9ef78619dd4f8a5704da0c13892a3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713680694fa24efa6d58916907948703"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a713680694fa24efa6d58916907948703">General_StrlcpyWithAlloc</a> (const char *src, signed long max_len)</td></tr>
<tr class="memdesc:a713680694fa24efa6d58916907948703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for a new string and copies up to max_len - 1 characters from the NUL-terminated string src to the new string, NUL-terminating the result This is meant to be a one stop shop for getting a copy of a string In this implementation, f_calloc with MEM_STANDARD is used.  <a href="general_8h.html#a713680694fa24efa6d58916907948703">More...</a><br /></td></tr>
<tr class="separator:a713680694fa24efa6d58916907948703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acad0656288c01f2f4c96f5e6ca0c61"><td class="memItemLeft" align="right" valign="top">signed long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a5acad0656288c01f2f4c96f5e6ca0c61">General_Strlcpy</a> (char *dst, const char *src, signed long max_len)</td></tr>
<tr class="memdesc:a5acad0656288c01f2f4c96f5e6ca0c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies up to max_len - 1 characters from the NUL-terminated string src to dst, NUL-terminating the result.  <a href="general_8h.html#a5acad0656288c01f2f4c96f5e6ca0c61">More...</a><br /></td></tr>
<tr class="separator:a5acad0656288c01f2f4c96f5e6ca0c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859a99b6609f93c025175b258696afba"><td class="memItemLeft" align="right" valign="top">signed long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a859a99b6609f93c025175b258696afba">General_Strlcat</a> (char *dst, const char *src, signed long max_len)</td></tr>
<tr class="memdesc:a859a99b6609f93c025175b258696afba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies up to max_len - 1 characters from the NUL-terminated string src and appends to the end of dst, NUL-terminating the result.  <a href="general_8h.html#a859a99b6609f93c025175b258696afba">More...</a><br /></td></tr>
<tr class="separator:a859a99b6609f93c025175b258696afba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea99e350b2f6f2813f64d400010e3b60"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#aea99e350b2f6f2813f64d400010e3b60">General_Strncmp</a> (const char *string_1, const char *string_2, size_t length)</td></tr>
<tr class="memdesc:aea99e350b2f6f2813f64d400010e3b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a case sensitive comparison of the specified number of characters of the two passed strings Stops processing once max_len has been reached, or when one of the two strings has run out of characters.  <a href="general_8h.html#aea99e350b2f6f2813f64d400010e3b60">More...</a><br /></td></tr>
<tr class="separator:aea99e350b2f6f2813f64d400010e3b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce61a7026c30f3f0d29f994e4471b61"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a6ce61a7026c30f3f0d29f994e4471b61">General_Strncasecmp</a> (const char *string_1, const char *string_2, size_t max_len)</td></tr>
<tr class="memdesc:a6ce61a7026c30f3f0d29f994e4471b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a case insensitive comparison of the specified number of characters of the two passed strings Stops processing once max_len has been reached, or when one of the two strings has run out of characters.  <a href="general_8h.html#a6ce61a7026c30f3f0d29f994e4471b61">More...</a><br /></td></tr>
<tr class="separator:a6ce61a7026c30f3f0d29f994e4471b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae49d06d93ef7b5d1aeae704a7722822"><td class="memItemLeft" align="right" valign="top">signed long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#aae49d06d93ef7b5d1aeae704a7722822">General_Strnlen</a> (const char *the_string, size_t max_len)</td></tr>
<tr class="memdesc:aae49d06d93ef7b5d1aeae704a7722822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the length of a fixed-size string Safe(r) strlen function: will stop processing if no terminator found before max_len reached.  <a href="general_8h.html#aae49d06d93ef7b5d1aeae704a7722822">More...</a><br /></td></tr>
<tr class="separator:aae49d06d93ef7b5d1aeae704a7722822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56721e3b15f39cd8df76755c8befa85a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a56721e3b15f39cd8df76755c8befa85a">General_CompareStringLength</a> (void *first_payload, void *second_payload)</td></tr>
<tr class="memdesc:a56721e3b15f39cd8df76755c8befa85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the length of two strings, returning true if the first is longer than the second.  <a href="general_8h.html#a56721e3b15f39cd8df76755c8befa85a">More...</a><br /></td></tr>
<tr class="separator:a56721e3b15f39cd8df76755c8befa85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde981427d1921294f66061a4d7ed11b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#abde981427d1921294f66061a4d7ed11b">General_ExtractFileExtensionFromFilename</a> (const char *the_file_name, char *the_extension)</td></tr>
<tr class="memdesc:abde981427d1921294f66061a4d7ed11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract file extension into the passed char pointer, as new lowercased string pointer, if any found.  <a href="general_8h.html#abde981427d1921294f66061a4d7ed11b">More...</a><br /></td></tr>
<tr class="separator:abde981427d1921294f66061a4d7ed11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b45cc507aab82cacfea2c888ed4feee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a9b45cc507aab82cacfea2c888ed4feee">General_DelayTicks</a> (int32_t ticks)</td></tr>
<tr class="memdesc:a9b45cc507aab82cacfea2c888ed4feee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the specified number of ticks before returning In multi-tasking ever becomes a thing, this is not a multi-tasking-friendly operation.  <a href="general_8h.html#a9b45cc507aab82cacfea2c888ed4feee">More...</a><br /></td></tr>
<tr class="separator:a9b45cc507aab82cacfea2c888ed4feee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31497a81342c86b3c2491eee833dfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#ae31497a81342c86b3c2491eee833dfce">General_DelaySeconds</a> (uint16_t seconds)</td></tr>
<tr class="memdesc:ae31497a81342c86b3c2491eee833dfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the specified number of seconds before returning In multi-tasking ever becomes a thing, this is not a multi-tasking-friendly operation.  <a href="general_8h.html#ae31497a81342c86b3c2491eee833dfce">More...</a><br /></td></tr>
<tr class="separator:ae31497a81342c86b3c2491eee833dfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a56721e3b15f39cd8df76755c8befa85a" name="a56721e3b15f39cd8df76755c8befa85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56721e3b15f39cd8df76755c8befa85a">&#9670;&nbsp;</a></span>General_CompareStringLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool General_CompareStringLength </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>first_payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>second_payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the length of two strings, returning true if the first is longer than the second. </p>
<p >This function accepts void* instead of char*, to be compatible with List_MergeSortedList(). NOTE: compares to a maximum of MAX_STRING_COMP_LEN </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_payload</td><td>the first string to compare, passed as a void pointer. </td></tr>
    <tr><td class="paramname">second_payload</td><td>the second string to compare, passed as a void pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the first string is longer than the second. Returns false if the strings are equivalent in length, or if second is longer. <br  />
 </dd></dl>

</div>
</div>
<a id="ae31497a81342c86b3c2491eee833dfce" name="ae31497a81342c86b3c2491eee833dfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31497a81342c86b3c2491eee833dfce">&#9670;&nbsp;</a></span>General_DelaySeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void General_DelaySeconds </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the specified number of seconds before returning In multi-tasking ever becomes a thing, this is not a multi-tasking-friendly operation. </p>
<p ><br  />
 </p>

</div>
</div>
<a id="a9b45cc507aab82cacfea2c888ed4feee" name="a9b45cc507aab82cacfea2c888ed4feee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b45cc507aab82cacfea2c888ed4feee">&#9670;&nbsp;</a></span>General_DelayTicks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void General_DelayTicks </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ticks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the specified number of ticks before returning In multi-tasking ever becomes a thing, this is not a multi-tasking-friendly operation. </p>
<p ><br  />
 </p>

</div>
</div>
<a id="abde981427d1921294f66061a4d7ed11b" name="abde981427d1921294f66061a4d7ed11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde981427d1921294f66061a4d7ed11b">&#9670;&nbsp;</a></span>General_ExtractFileExtensionFromFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool General_ExtractFileExtensionFromFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>the_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>the_extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract file extension into the passed char pointer, as new lowercased string pointer, if any found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_file_name</td><td>the file name to extract an extension from </td></tr>
    <tr><td class="paramname">the_extension</td><td>a pre-allocated buffer that will contain the extension, if any is detected. Must be large enough to hold the extension! No bounds checking is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if no file extension found. </dd></dl>

</div>
</div>
<a id="a6d15a10ba145726c598611b6eb97cf0d" name="a6d15a10ba145726c598611b6eb97cf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d15a10ba145726c598611b6eb97cf0d">&#9670;&nbsp;</a></span>General_Round()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t General_Round </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>the_float</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round a float to the nearest integer value THINK C's and SAS/C's math.h don't include round() from: <a href="https://stackoverflow.com/questions/4572556/concise-way-to-implement-round-in-c">https://stackoverflow.com/questions/4572556/concise-way-to-implement-round-in-c</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_float</td><td>a double value to round up/down </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an int with the rounded value </dd></dl>

</div>
</div>
<a id="a859a99b6609f93c025175b258696afba" name="a859a99b6609f93c025175b258696afba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859a99b6609f93c025175b258696afba">&#9670;&nbsp;</a></span>General_Strlcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed long General_Strlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed long&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies up to max_len - 1 characters from the NUL-terminated string src and appends to the end of dst, NUL-terminating the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The string to copy </td></tr>
    <tr><td class="paramname">dst</td><td>The string to append to. Calling function is responsible for ensuring this string is allocated, and has at least as much storage as max_len. </td></tr>
    <tr><td class="paramname">max_len</td><td>The maximum number of bytes to use in the destination string, including the terminator. If this is shorter than the length of src + length of dst + 1, the resulting copy string will be capped at max_len - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the length of the attempted concatenated string: initial length of dst plus the length of src. </dd></dl>

</div>
</div>
<a id="a5acad0656288c01f2f4c96f5e6ca0c61" name="a5acad0656288c01f2f4c96f5e6ca0c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acad0656288c01f2f4c96f5e6ca0c61">&#9670;&nbsp;</a></span>General_Strlcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed long General_Strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed long&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies up to max_len - 1 characters from the NUL-terminated string src to dst, NUL-terminating the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The string to copy </td></tr>
    <tr><td class="paramname">dst</td><td>The string to copy into. Calling function is responsible for ensuring this string is allocated, and has at least as much storage as max_len. </td></tr>
    <tr><td class="paramname">max_len</td><td>The maximum number of bytes to use in the destination string, including the terminator. If this is shorter than the length of the source string + 1, the resulting copy string will be capped at max_len - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the length of the source string, or -1 on any error condition </dd></dl>

</div>
</div>
<a id="a713680694fa24efa6d58916907948703" name="a713680694fa24efa6d58916907948703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713680694fa24efa6d58916907948703">&#9670;&nbsp;</a></span>General_StrlcpyWithAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * General_StrlcpyWithAlloc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed long&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for a new string and copies up to max_len - 1 characters from the NUL-terminated string src to the new string, NUL-terminating the result This is meant to be a one stop shop for getting a copy of a string In this implementation, f_calloc with MEM_STANDARD is used. </p>
<p >When freeing the returned string, use f_free with MEM_STANDARD. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The string to copy </td></tr>
    <tr><td class="paramname">max_len</td><td>The maximum number of bytes to use in the destination string, including the terminator. If this is shorter than the length of the source string + 1, the resulting copy string will be capped at max_len - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the source string to max_len, or NULL on any error condition </dd></dl>

</div>
</div>
<a id="a6ce61a7026c30f3f0d29f994e4471b61" name="a6ce61a7026c30f3f0d29f994e4471b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce61a7026c30f3f0d29f994e4471b61">&#9670;&nbsp;</a></span>General_Strncasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t General_Strncasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a case insensitive comparison of the specified number of characters of the two passed strings Stops processing once max_len has been reached, or when one of the two strings has run out of characters. </p>
<p >Inspired by code from slashdot and apple open source <a href="https://stackoverflow.com/questions/5820810/case-insensitive-string-comparison-in-c">https://stackoverflow.com/questions/5820810/case-insensitive-string-comparison-in-c</a> <a href="https://opensource.apple.com/source/tcl/tcl-10/tcl/compat/strncasecmp.c.auto.html">https://opensource.apple.com/source/tcl/tcl-10/tcl/compat/strncasecmp.c.auto.html</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_1</td><td>the first string to compare. </td></tr>
    <tr><td class="paramname">string_2</td><td>the second string to compare. </td></tr>
    <tr><td class="paramname">max_len</td><td>the maximum number of characters to compare. Even if both strings are larger than this number, only this many characters will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the strings are equivalent (at least up to max_len). Returns a negative or positive if the strings are different. </dd></dl>

</div>
</div>
<a id="aea99e350b2f6f2813f64d400010e3b60" name="aea99e350b2f6f2813f64d400010e3b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea99e350b2f6f2813f64d400010e3b60">&#9670;&nbsp;</a></span>General_Strncmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t General_Strncmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a case sensitive comparison of the specified number of characters of the two passed strings Stops processing once max_len has been reached, or when one of the two strings has run out of characters. </p>
<p ><a href="http://home.snafu.de/kdschem/c.dir/strings.dir/strncmp.c">http://home.snafu.de/kdschem/c.dir/strings.dir/strncmp.c</a> TODO: compare this to other implementations, see which is faster. eg, <a href="https://opensource.apple.com/source/Libc/Libc-167/gen.subproj/i386.subproj/strncmp.c.auto.html">https://opensource.apple.com/source/Libc/Libc-167/gen.subproj/i386.subproj/strncmp.c.auto.html</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_1</td><td>the first string to compare. </td></tr>
    <tr><td class="paramname">string_2</td><td>the second string to compare. </td></tr>
    <tr><td class="paramname">max_len</td><td>the maximum number of characters to compare. Even if both strings are larger than this number, only this many characters will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the strings are equivalent (at least up to max_len). Returns a negative or positive if the strings are different. </dd></dl>

</div>
</div>
<a id="aae49d06d93ef7b5d1aeae704a7722822" name="aae49d06d93ef7b5d1aeae704a7722822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae49d06d93ef7b5d1aeae704a7722822">&#9670;&nbsp;</a></span>General_Strnlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed long General_Strnlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>the_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the length of a fixed-size string Safe(r) strlen function: will stop processing if no terminator found before max_len reached. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns strlen(the_string), if that is less than max_len, or max_len if there is no null terminating ('\0') among the first max_len characters pointed to by the_string. </dd></dl>

</div>
</div>
<a id="ad1db800160346891a591a3525a25ef0c" name="ad1db800160346891a591a3525a25ef0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1db800160346891a591a3525a25ef0c">&#9670;&nbsp;</a></span>General_StrToLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool General_StrToLower </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>the_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string, in place, to lower case This overwrites the string with a lower case version of itself. </p>
<p >Warning: no length check is in place. Calling function must verify string is well-formed (terminated). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_string</td><td>the string to convert to lower case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the string was modified by the process. </dd></dl>

</div>
</div>
<a id="aa9ef78619dd4f8a5704da0c13892a3b7" name="aa9ef78619dd4f8a5704da0c13892a3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ef78619dd4f8a5704da0c13892a3b7">&#9670;&nbsp;</a></span>General_ToLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char General_ToLower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>the_char</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the case of the passed character from upper to lower (if necessary) Scope is limited to characters A-Z, ascii. </p>
<p >replacement for tolower() in c library, which doesn't seem to work [in Amiga WB2K] for some reason. </p><dl class="section return"><dt>Returns</dt><dd>a character containing the lowercase version of the passed character. </dd></dl>

</div>
</div>
<a id="ac9d5562510f9cb5809bc5e5b640f07a8" name="ac9d5562510f9cb5809bc5e5b640f07a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d5562510f9cb5809bc5e5b640f07a8">&#9670;&nbsp;</a></span>General_WrapAndTrimTextToFit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t General_WrapAndTrimTextToFit </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>orig_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>formatted_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>max_chars_to_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>max_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>max_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>one_char_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>one_row_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_font.html">Font</a> *&#160;</td>
          <td class="paramname"><em>the_font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t(*)(<a class="el" href="struct_font.html">Font</a> *, char *, int16_t, int16_t, int16_t, int16_t *)&#160;</td>
          <td class="paramname"><em>measure_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a string by wrapping and trimming to fit the passed width and height. </p>
<p >If the string cannot be displayed in the specified height and width, processing will stop, but it is not an error condition </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_string</td><td>pointer to a string pointer that holds the text to be formatted. Upon return, this pointer will point to the next character after the last processed character (if the string was too long to fit). If the entire string fits, this pointer will not be adjusted. </td></tr>
    <tr><td class="paramname">formatted_string</td><td>pointer to a string pointer to an empty string buffer that will be filled with the formatted version of the text. </td></tr>
    <tr><td class="paramname">max_chars_to_format</td><td>the length of the string to format (in characters). If max_chars_to_format is less than the length of string, processing will stop after that many characters. </td></tr>
    <tr><td class="paramname">max_width</td><td>the width into which the text must fit, in pixels. </td></tr>
    <tr><td class="paramname">max_height</td><td>the height into which the text must fit, in pixels. Pass a 0 to disable the governor on vertical space. </td></tr>
    <tr><td class="paramname">one_char_width</td><td>the width in pixels, of one character. NOTE: This is only used for fixed-width, text mode operations. </td></tr>
    <tr><td class="paramname">one_row_height</td><td>the height in pixels, of one row of text, including any leading. </td></tr>
    <tr><td class="paramname">the_font</td><td>the font object to be used in measuring width. This is optional and ignore if called for text mode operations. </td></tr>
    <tr><td class="paramname">measure_function</td><td>pointer to the function responsible for measuring the graphical width of a string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of vertical pixels required. Returns -1 in any error condition. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="general_8h.html">general.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
